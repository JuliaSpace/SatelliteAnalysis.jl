var documenterSearchIndex = {"docs":
[{"location":"man/ground_track/#Ground-Track","page":"Ground Track","title":"Ground Track","text":"","category":"section"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"using SatelliteAnalysis","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"We can obtain the ground track of a satellite using the function:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"ground_track(orbp::OrbitPropagator; kwargs...) -> Vector{NTuple{2, Float64}}","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"It computes the satellite ground track using the orbit propagator orbp. It returns a vector of NTuple{2, Float64} where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the ground track.","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"The following keywords are available:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"add_nans::Bool: If true, we add NaN if there is a discontinuity in the ground track   to improve plotting.   (Default: true)\nduration::Number: Duration of the analysis.   (Default: 86400)\ninitial_time::Number: Initial time regarding the orbit propagator orbp epoch [s].   (Default: 0)\nf_eci_to_ecef::Function: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be\nf_eci_to_ecef(r_i::AbstractVector, jd::Number) -> AbstractVector\nand it must return the position vector r_i represented in the ECEF at the instant jd   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (Default: _ground_track_default_eci_to_ecef)\nstep::Union{Nothing, Number}: Step for the computation. If nothing, we will roughly   compute the step to approximate 1° in the mean anomaly.   (Default: nothing)\ntrack_types::Symbol: A symbol describing what kind of track types we must add to the   output vector. It can be :ascending for only ascending passages, :descending for   only descending passages, or :all for both.   (Default: :all)","category":"page"},{"location":"man/ground_track/#Ground-Track-Inclination","page":"Ground Track","title":"Ground Track Inclination","text":"","category":"section"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"Many analyses require the ground track inclination. For example, if we are designing a remote sensing mission with an optical payload, we must know how much two images overlap. This information can only be computed using spherical trigonometry and the ground track inclination instead of the orbital one.","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"The ground track inclination i_gt, shown in the following figure, is a composition of the orbit inclination, the Earth's angular speed, and the RAAN time derivative. We can compute it using:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"i_gt = tan^-1left(frac\n    omega_s sin i \n\n    omega_s cos i - omega_e + dotOmega\nright) ","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"where i is the orbital inclination, omega_s is the satellite angular speed at Equator, omega_e is the Earth angular speed, and Omega is the RAAN.","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"<div align=\"center\">\n  <img src=\"../../assets/ground_track_inclination.png\" alt=\"Ground Track Inclination\" width=\"100%\"/>\n</div>","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"Formally, we should use the satellite instantaneous angular speed at the Equator in omega_s. However, given the perturbations caused by the Earth's gravitational potential, this speed is not simple to compute. The calculation would required to implement an orbit propagator. Thus, we simplify it by assuming that the orbit eccentricity is small. This assumption is reasonable given the missions that would benefit from the computation of the ground track inclination. In this case, we approximate omega_s as the mean satellite angular speed.","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"The function:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"ground_track_inclination(a::Number, e::Number, i::Number; kwargs...) -> T\nground_track_inclination(orb::Orbit{Tepoch, T}); kwargs...) where {Tepoch <: Number, T <: Number} -> T","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"computes the ground track inclination at the Equator [rad] in an orbit with semi-major axis a [m], eccentricity e [ ], and inclination i [rad]. The orbit can also be specified by orb (see Orbit).","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"note: Note\nThe output type T in the first signature is obtained by promoting the inputs to a float type.","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"The following keywords are available:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"perturbation::Symbol: Symbol to select the perturbation terms that will be used. It can   be :J0, :J2, or :J4.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default: GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default: EGM_2008_J2)\nJ4::Number: J₄ perturbation term.   (Default: EGM_2008_J4)\nR0::Number: Earth's equatorial radius [m].   (Default: EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)","category":"page"},{"location":"man/ground_track/#Examples","page":"Ground Track","title":"Examples","text":"","category":"section"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"We will compute the descending ground tracks of the Amazonia-1 mission for five days. The first thing we need to do is define the orbit:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"jd₀ = date_to_jd(2021, 1, 1)\n\norb = KeplerianElements(\n    jd₀,\n    7130.982e3,\n    0.001111,\n    98.405 |> deg2rad,\n    ltdn_to_raan(10.5, jd₀),\n    π / 2,\n    0\n)","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"The next step is to define the desired propagator:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"orbp = Propagators.init(Val(:J2), orb)","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"Now, we can use the function ground_track to obtain the satellite ground track considering only the descending passages:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"gt = ground_track(orbp; duration = 5 * 86400, track_types = :descending)","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"Finally, we can extract the latitude and longitude of each point in the ground track using:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"gt_lat = first.(gt)\ngt_lon = last.(gt)","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"If we use GeoMakie.jl to plot, we obtain:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"using GeoMakie, CairoMakie\n\nfig, ax = plot_ground_track(gt)\n\nax.title = \"Amazonia-1 Descending Ground Tracks\"\n\nsave(\"amz1_descending_ground_tracks.png\", fig)","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"(Image: Amazonia-1 descending ground track)","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"Finally, the ground track inclination is:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"ground_track_inclination(orb) |> rad2deg","category":"page"},{"location":"man/ground_track/#Plotting","page":"Ground Track","title":"Plotting","text":"","category":"section"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"If the user loads the package GeoMakie.jl together with a Makie.jl back end, an extension is loaded and adds the possibility to plot the ground track. In this case, the following function is available:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"plot_ground_track(gt::Vector{NTuple{2, T}}; kwargs...) where T<:Number -> Figure, Axis","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"It plots the ground track gt computed using the function ground_track. It returns the objects Figure and Axis used to plot the data. For more information, please, refer to Makie.jl documentation.","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"All kwargs... are passed to the function Figure.","category":"page"},{"location":"man/ground_track/#Example","page":"Ground Track","title":"Example","text":"","category":"section"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"The code:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"using GeoMakie, CairoMakie\n\njd₀ = date_to_jd(2021, 1, 1)\n\norb = KeplerianElements(\n    jd₀,\n    7130.982e3,\n    0.001111,\n    98.405 |> deg2rad,\n    ltdn_to_raan(10.5, jd₀),\n    π / 2,\n    0\n)\n\norbp = Propagators.init(Val(:J2), orb)\n\ngt = ground_track(orbp; duration = 5 * 86400, track_types = :ascending)\n\nfig, ax = plot_ground_track(gt)\n\nsave(\"ground_track.png\", fig)","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"produces the following figure:","category":"page"},{"location":"man/ground_track/","page":"Ground Track","title":"Ground Track","text":"(Image: Ground track)","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/#Ground-Facility-Accesses","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"using SatelliteAnalysis","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"We can use the function:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"ground_facility_accesses(orbp, [(WGS84)]; kwargs...) -> DataFrame","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"to compute the accesses of a satellite with orbit propagator orbp (see Propagators.init) to the ground facilities defined in the vector [(WGS84)]. The analysis interval begins in the propagator epoch plus initial_time and lasts for duration [s], where both are keywords.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"The ground facilities are specified using a vector of tuples with three numbers:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"Tuple{T1, T2, T3} where {T1 <: Number, T2 <: Number, T3 <: Number}","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"containing the WGS84 position of each ground facility [(WGS84)]:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"(latitude [rad], longitude [rad], altitude [m])","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"Those geodetic information are transformed to an ECEF vector using the function geodetic_to_ecef.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"The following keywords are available:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"duration::Number: Duration of the analysis [s].   (Default = 86400)\nf_eci_to_ecef::Function: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be\nf_eci_to_ecef(r_i::AbstractVector, jd::Number) -> AbstractVector\nand it must return the position vector r_i represented in the ECEF at the instant jd   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (Default: _ground_facility_default_eci_to_ecef)\ninitial_time::Number: Initial time of the analysis after the propagator epoch [s].   (Default = 0)\nminimum_elevation::Number: Minimum elevation angle for communication between the   satellite and the ground facilities [rad].   (Default = 10°)\nreduction::Function: A function that receives a boolean vector with the visibility   between the satellite and each ground facility. It must return a boolean value   indicating if the access must be computed or not. This is useful to merge access time   between two or more facilities.   (Default = v -> |(v...) i.e. compute the access if at least one ground   facilities is visible)\nstep::Number: The step [s] used to propagate the orbit. Notice that we perform a cross   tuning to accurately obtain the access time. However, if an access is lower than the   step, it can be neglected.   (Default = 60)\nunit::Symbol: Select the unit in which the duration will be computed. The possible   values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"This function returns a DataFrame with three columns:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"access_beginning: Time of the access beginning [UTC] encoded using DateTime.\naccess_end: Time of the access end [UTC] encoded using DateTime.\nduration: Duration of the access [s]. The unit of the column duration is stored in the DataFrame using metadata.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/#Examples","page":"Ground Facility Accesses","title":"Examples","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"Let's compute the access time of the Amazonia-1 satellite to the INPE's ground station at Cuiabá, MT, Brazil.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"First, we need to define an orbit propagator. In this case, we will use the TLE obtained from CelesTrak when this documentation was written:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"tle_amz1 = tle\"\"\"\n    AMAZONIA 1\n    1 47699U 21015A   24008.13079366  .00000299  00000+0  10693-3 0  9994\n    2 47699  98.4120  87.2350 0001570  92.1147 268.0222 14.40836963150331\n    \"\"\"\n\norbp = Propagators.init(Val(:SGP4), tle_amz1)","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"Now, we can compute the access time during one day considering the INPE's station at Cuiabá:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"ground_facility_accesses(\n    orbp,\n    [(-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)];\n    duration = 1 * 86400,\n    minimum_elevation = 5 |> deg2rad,\n    unit = :m\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"If we want to change the reference frames used in the analysis, we must provide a function f_eci_to_ecef(r_i, jd) that converts the vector r_i to the desired ECEF frame at the instant jd [Julian Day]. For example, let's use the more precise ITRF instead of the PEF (default):","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"const eop = fetch_iers_eop(Val(:IAU1980));\n\nfunction f_eci_to_ecef(r_teme, jd)\n    D_itrf_teme = r_eci_to_ecef(TEME(), ITRF(), jd, eop)\n    r_itrf = D_itrf_teme * r_teme\n    return r_itrf\nend\n\nground_facility_accesses(\n    orbp,\n    [(-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)];\n    duration = 1 * 86400,\n    f_eci_to_ecef = f_eci_to_ecef,\n    minimum_elevation = 5 |> deg2rad,\n    unit = :m\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"We can also perform analyses using multiple ground facilities. For example, let's find the accumulated access if we consider the INPE's stations at Cuiabá, MT, Brazil, and Alcântara, MA, Brazil:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"ground_facility_accesses(\n    orbp,\n    [\n        (-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)\n        (-( 2 + 20 / 60) |> deg2rad, -(44 + 24 / 60) |> deg2rad, 0)\n    ];\n    duration = 1 * 86400,\n    minimum_elevation = 5 |> deg2rad,\n    unit = :m\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"By default, the algorithm computes the accumulated access, i.e., it considers the access active if either station has visibility to the satellite. We can change this logic by overloading the function in the keyword parameter reduction. For example, let's compute only the accesses when the satellite has visibility to both ground stations at the same time:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"ground_facility_accesses(\n    orbp,\n    [\n        (-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)\n        (-( 2 + 20 / 60) |> deg2rad, -(44 + 24 / 60) |> deg2rad, 0)\n    ];\n    duration = 1 * 86400,\n    minimum_elevation = 5 |> deg2rad,\n    reduction = v -> (&)(v...),\n    unit = :m\n)","category":"page"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/","page":"Library","title":"Library","text":"Documentation for SatelliteAnalysis.jl.","category":"page"},{"location":"lib/library/","page":"Library","title":"Library","text":"Modules = [SatelliteAnalysis]","category":"page"},{"location":"lib/library/#SatelliteAnalysis._F_and_∂F_l0p-Tuple{Integer, Integer, Number}","page":"Library","title":"SatelliteAnalysis._F_and_∂F_l0p","text":"_F_and_∂F_l0p(l::Integer, p::Integer, i::Number) -> BigFloat, BigFloat\n\nCompute the inclination function F_{l,0,p}(i) and its derivative ∂F_{l,0,p} / ∂ias defined in [1, p. 642].\n\nnote: Note\nInternally, we must use BigFloat to allow calculations on high degrees.\n\nReferences\n\n[1] Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications. 4th ed.   Microcosm Press, Hawthorne, CA.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.beta_angle-Tuple{KeplerianElements, Number}","page":"Library","title":"SatelliteAnalysis.beta_angle","text":"beta_angle(orb::KerplerianElements{Tepoch, T}, Δjd::Number; kwargs...) -> Float64\n\nCompute the beta angle [rad] for the orbit orb after Δjd days from its epoch.\n\nThe algorithm was obtained from [1].\n\nnote: Note\nIt is expected that the input elements are represented in the TOD reference frame. If it is not the case, they can be converted using the function orb_eci_to_eci of SatelliteToolboxTransformations.jl.\n\nKeywords\n\nperturbation::Symbol: Select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J₂.\n:J4: Consider the perturbation terms J₂, J₂², and J₄.\n(Default: :J2)\n\nReferences\n\n[1]: Mortari, D., Wilkins, M. P., and Bruccoleri, C.  On Sun-Synchronous Orbits and   Associated Constellations\n\nExtended Help\n\nThe beta angle is the angle between the orbit plane and the Sun. The positive direction is defined as that of the orbit angular momentum.\n\nThe beta angle is useful when computing the mean amount of solar radiation a satellite receives in a particular orbit.\n\nExamples\n\njulia> using SatelliteAnalysis, UnicodePlots\n\njulia> jd₀ = date_to_jd(2021, 1, 1, 0, 0, 0)\n\njulia> orb = KeplerianElements(\n            jd₀,\n            7130.982e3,\n            0.001111,\n            98.405 |> deg2rad,\n            ltdn_to_raan(10.5, jd₀),\n            90     |> deg2rad,\n            0\n        )\n\njulia> β = beta_angle.(orb, 0:1:364)\n\njulia> lineplot(0:1:364, rad2deg.(β), xlabel = \"Day\", ylabel = \"Beta angle [°]\")\n                     ┌────────────────────────────────────────┐\n                  30 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⣠⠞⠉⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⡴⠁⠀⠀⠀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠃⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠁⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⠀⠀⠀⠀⠀⠀⣠⠞⠀⠀⠀⠀⠀⠀│\n   Beta angle [°]    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠋⠀⠀⠀⠉⠓⠲⠤⠴⠚⠁⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣄⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠦⣄⣀⡠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                  10 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     └────────────────────────────────────────┘\n                     ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀400⠀\n                     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Day⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.design_sun_sync_ground_repeating_orbit-Tuple{Int64, Int64}","page":"Library","title":"SatelliteAnalysis.design_sun_sync_ground_repeating_orbit","text":"design_sun_sync_ground_repeating_orbit(minimum_repetition::Int, maximum_repetition::Int; kwargs...) -> DataFrame\n\nList all the Sun synchronous, ground repeating orbits in which their repetition period is in the interval [minimum_repetition, maximum_repetition] days.\n\nThis function returns a DataFrame with the following columns:\n\nsemi_major_axis: Orbit semi-major axis.\naltitude: Orbit altitude above the Equator (a - R0).\ninclination: Orbit inclination.\nperiod: Orbital period.\nrev_per_days: If the keyword pretify_rev_per_days is false, this column contains   Tuples with the integer and rational parts of the number of revolutions per day.   Otherwise, it contains a string with a prety representation of the number of revolutions   per day.\nadjacent_gt_distance: Distance between two adjacent ground tracks at Equator.\nadjacent_gt_angle: Angle between two adjacent ground tracks at Equator measured from the   satellite position.\n\nnote: Note\nThe units of those columns depends on the keywords.\n\nKeywords\n\nangle_unit::Symbol: Unit for all the angles in the output DataFrame.  It can be :deg   for degrees or :rad for radians.   (Default: :deg)\ndistance_unit::Symbol: The unit for all the distances in the output DataFrame. It can   be :m for meters or :km for kilometers.   (Default: :km)\neccentricity::Number: Orbit eccentricity.   (Default: 0)\nint_rev_per_day::Tuple: Tuple with the integer parts of the number of revolutions per   day to be analyzed.   (Default = (13, 14, 15, 16, 17))\npretity_rev_per_days::Bool: If true, the column with the revolutions per day will be   conveted to a string with a pretty representation of this information.   (Default: true)\nmaximum_altitude::Union{Nothing, Number}: Maximum altitude [m] of the orbits in the   output DataFrame. If it is nothing, the algorithm will not apply a higher limit to   the orbital altitude.   (Default = nothing)\nminimum_altitude::Union{Nothing, Number}: Minimum altitude [m] of the orbits in the   output DataFrame. If it is nothing, the algorithm will not apply a lower limit to   the orbital altitude.   (Default = nothing)\ntime_unit::Symbol: Unit for all the time values in the output DataFrame.  It can be   :s for seconds, :m for minutes, or :h for hours.   (Default = :h)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.eclipse_time_summary-Tuple{OrbitPropagator}","page":"Library","title":"SatelliteAnalysis.eclipse_time_summary","text":"eclipse_time_summary(orbp::OrbitPropagator; kwargs...) -> DataFrame\n\nCompute the eclipse time summary for the orbit propagator orbp. The summary is computed as the total time the object stays in the sunlight, penumbra, and umbra regions per orbit at each day.\n\nKeywords\n\nnum_days::Number: Number of days in which the analysis will be performed.   (Default = 365)\nstep::Number: The step in which the propagation will occur. Notice that this function   has a crossing estimation to accurately estimate the transition between the regions.   However, if this step is very large, we may miss some small regions. If it is negative,   it will be selected as the time in which the mean anomaly advances 0.5°.   (Default = -1)\nunit::Symbol: Select the unit in which the results will be generated. The possible   values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.\n\nReturns\n\nDataFrame: The function returns a DataFrame with three columns:\nsunlight: Total sunlight time per orbit at each day [unit].\npenumbra: Total penumbra time per orbit at each day [unit].\numbra: Total umbra time per orbit at each day [unit].\nThe unit of each column is stored in the DataFrame using metadata.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> orb = KeplerianElements(\n           date_to_jd(2021, 1, 1, 0, 0, 0),\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           90     |> deg2rad,\n           0\n       )\n\njulia> orbp = Propagators.init(Val(:J2), orb)\n\njulia> df = eclipse_time_summary(orbp; num_days = 5)\n5×4 DataFrame\n Row │ date        sunlight  penumbra  umbra\n     │ Date        Float64   Float64   Float64\n─────┼─────────────────────────────────────────\n   1 │ 2021-01-01   3972.63   20.4117  2006.96\n   2 │ 2021-01-02   3973.85   20.4376  2005.71\n   3 │ 2021-01-03   3974.77   20.4575  2004.77\n   4 │ 2021-01-04   3975.74   20.4758  2003.79\n   5 │ 2021-01-05   3976.94   20.5022  2002.55\n\njulia> df = eclipse_time_summary(orbp; num_days = 5, unit = :m)\n5×4 DataFrame\n Row │ date        sunlight  penumbra  umbra\n     │ Date        Float64   Float64   Float64\n─────┼─────────────────────────────────────────\n   1 │ 2021-01-01   66.2105  0.340195  33.4493\n   2 │ 2021-01-02   66.2308  0.340627  33.4285\n   3 │ 2021-01-03   66.2461  0.340958  33.4129\n   4 │ 2021-01-04   66.2623  0.341263  33.3964\n   5 │ 2021-01-05   66.2824  0.341704  33.3759\n\njulia> colmetadata(df)\nDict{Symbol, Dict{String, Symbol}} with 3 entries:\n  :penumbra => Dict(\"Unit\"=>:m)\n  :sunlight => Dict(\"Unit\"=>:m)\n  :umbra    => Dict(\"Unit\"=>:m)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.fetch_country_polygons","page":"Library","title":"SatelliteAnalysis.fetch_country_polygons","text":"fetch_country_polygons(url = \"https://pkgstore.datahub.io/core/geo-countries/countries/archive/23f420f929e0e09c39d916b8aaa166fb/countries.geojson\"; kwargs...) -> String\n\nFetch the GeoJSON file with the country polygons in url. The algorithm stores the file in a scratch space. The function returns a String with the file path.\n\nnote: Note\nIf the file has already been downloaded, this function only returns its path. However, if the keyword force_download is true, the file is downloaded again from url.\n\nKeywords\n\nforce_download::Bool: Download the file from url even if it already exists.   (Default = false)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteAnalysis.find_crossing-Union{Tuple{N}, Tuple{Function, Number, Number, Any, Any, Vararg{Any, N}}} where N","page":"Library","title":"SatelliteAnalysis.find_crossing","text":"find_crossing(f::Function, t₀::Number, t₁::Number, s₀, s₁, vargs...; Δ = 1e-3, max = 100, kwargs...) -> T\n\nReturn the crossing time tc in which the function f(t) goes from the state s₀ to the state s₁. It is assumed that f(t₀) = s₀ and f(t₁) = s₁.\n\nThe parameters in vargs... are passed to the function f after t, and the keywords kwargs... are also passed to f. Hence, it will always be called as f(t, vargs...; kwargs...).\n\nIf the computed interval is smaller than Δ, or if the number of iterations is higher than max, the algorithm stops.\n\nnote: Note\nThe output type T is obtained by the type of (t₁ + t₂) / 2.\n\nExamples\n\njulia> SatelliteAnalysis.find_crossing(\n    t -> (sin(t) > 0),\n    -0.3,\n    0.3,\n    false,\n    true;\n    Δ = 1e-10\n)\n6.984919309616089e-11\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.frozen_orbit-Tuple{Number, Number}","page":"Library","title":"SatelliteAnalysis.frozen_orbit","text":"frozen_orbit(a::Number, i::Number; kwargs...) -> Float64, Float64\n\nCompute the eccentricity [ ] and argument of perigee [rad] to obtain a frozen orbit when the orbit has semi-major axis a [m] and inclination i [rad]. This function uses the theory in [1].\n\nnote: Note\nThis function uses BigFloat internally to perform all computations, allowing very high degrees. However, the user must ensure that the default precision is enough for the required degree. Refer to the function setprecision for more information.\n\nKeywords\n\ngravity_model::Union{Nothing, AbstractGravityModel}: Gravity model used to compute the   frozen eccentricity. Refer to the object AbstractGravityModel of the package   SatelliteToolboxGravityModels.jl for more information. If it is nothing, the system   will automatically fetch and load the EGM96 gravity model. However, loading a gravity   model can significantly decrease the performance. Thus, it is advisable to pass a   gravity model here.   (Default = nothing)\nmax_degree: Maximum gravity model degree used to compute the frozen eccentricity. If it   is equal to or lower than 0, the maximum degree in grav_model will be used. Otherwise,   if it is lower than 3 or higher than the grav_model maximum degree, it will be clamped   accordingly.   (Default = 53)\n\nReferences\n\n[1] Rosborough, G. W.; Ocampo, C. A (1991). Influence of higher degree zonals on the   frozen orbit geometry. Proceedings of the AAS/AIAA Astrodynamics Conference, Durango,   CO.\n\nExtended Help\n\nDue to the Earth's gravitational perturbation, the orbit of a salite will experience secular changes in the argument of perigee. Hence, the satellite mean altitude per latitude will differ during the mission. This effect can be problematic, especially if we must compare images by a camera onboard the satellite in different periods. The altitude variation will change the resolution, leading to some problems when comparing the data.\n\nWe can avoid this problem if we compute an eccentricity and the argument of perigee that yields theoretically:\n\nde      dω\n── = 0, ── = 0\ndt      dt\n\nThis orbit is called frozen. Refer to [1] for more information.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> frozen_orbit(7130.982e3, 98.410 |> deg2rad)\n(0.0011641853028456078, 1.5707963267948966)\n\njulia> jgm3 = GravityModels.load(IcgemFile, fetch_icgem_file(:JGM3))\n[ Info: Downloading the ICGEM file 'JGM3.gfc' from 'http://icgem.gfz-potsdam.de/getmodel/gfc/a3375e01a717ac162962138a5e94f10\n466b71aa4a130d7f7d5b18ab3d5f90c3d/JGM3.gfc'...\nIcgemFile{Float64}:\n      Product type : gravity_field\n       Model name  : JGM3\n  Gravity constant : 3.986004415e14\n            Radius : 6.3781363e6\n    Maximum degree : 70\n            Errors : formal\n       Tide system : unknown\n              Norm : fully_normalized\n         Data type : Float64\n\njulia> frozen_orbit(7130.982e3, 98.410 |> deg2rad; gravity_model = jgm3)\n(0.001163484769069545, 1.5707963267948966)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_facility_accesses-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_facility_accesses","text":"ground_facility_accesses(orbp, [(WGS84)]; kwargs...) -> DataFrame\n\nCompute the accesses of a satellite with orbit propagator orbp (see Propagators.init) to the ground facilities defined in the vector [(WGS84)]. The analysis interval begins in the propagator epoch plus initial_time and lasts for duration [s], where both are keywords.\n\nThe ground facilities are specified using a vector of tuples with three numbers:\n\nTuple{T1, T2, T3} where {T1 <: Number, T2 <: Number, T3 <: Number}\n\ncontaining the WGS84 position of each ground facility [(WGS84)]:\n\n(latitude [rad], longitude [rad], altitude [m])\n\nThose geodetic information are transformed to an ECEF vector using the function geodetic_to_ecef.\n\nKeywords\n\nduration::Number: Duration of the analysis [s].   (Default = 86400)\nf_eci_to_ecef::Function: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be\njulia   f_eci_to_ecef(r_i::AbstractVector, jd::Number) -> AbstractVector\nand it must return the position vector r_i represented in the ECEF at the instant jd   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (Default: _ground_facility_default_eci_to_ecef)\ninitial_time::Number: Initial time of the analysis after the propagator epoch [s].   (Default = 0)\nminimum_elevation::Number: Minimum elevation angle for communication between the   satellite and the ground facilities [rad].   (Default = 10°)\nreduction::Function: A function that receives a boolean vector with the visibility   between the satellite and each ground facility. It must return a boolean value   indicating if the access must be computed or not. This is useful to merge access time   between two or more facilities.   (Default = v -> |(v...) i.e. compute the access if at least one ground   facilities is visible)\nstep::Number: The step [s] used to propagate the orbit. Notice that we perform a cross   tuning to accurately obtain the access time. However, if an access is lower than the   step, it can be neglected.   (Default = 60)\nunit::Symbol: Select the unit in which the duration will be computed. The possible   values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.\n\nReturns\n\nDataFrame: The function returns a DataFrame with three columns:\naccess_beginning: Time of the access beginning [UTC] encoded using DateTime.\naccess_end: Time of the access end [UTC] encoded using DateTime.\nduration: Duration of the access [s].\nThe unit of the column duration is stored in the DataFrame using metadata.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> jd₀ = date_to_jd(2024, 1, 1);\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       );\n\njulia> orbp = Propagators.init(Val(:J2), orb);\n\njulia> ground_facility_accesses(orbp, (0, 0, 0))\n2×3 DataFrame\n Row │ access_beginning         access_end               duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T10:20:03.136  2024-01-01T10:30:02.971   599.835\n   2 │ 2024-01-01T22:49:55.910  2024-01-01T22:59:23.470   567.56\n\njulia> ground_facility_accesses(orbp, (0, 0, 0); unit = :m)\n2×3 DataFrame\n Row │ access_beginning         access_end               duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T10:20:03.136  2024-01-01T10:30:02.971   9.99725\n   2 │ 2024-01-01T22:49:55.910  2024-01-01T22:59:23.470   9.45933\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_facility_gaps-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_facility_gaps","text":"ground_facility_gaps(orbp, args...; duration::Number = 86400, initial_time::Number = 0, kwargs...) -> DataFrame\n\nCompute the gaps between the accesses of ground facilities. The arguments and keywords are the same as the ones used in the function ground_facility_accesses.\n\nNotice that the gap analysis starts in the orbit propagator epoch plus initial_time and lasts for duration [s].\n\nReturns\n\nDataFrame: The function returns a DataFrame with three columns:\ngap_beginning: Time of the access beginning [UTC] encoded using DateTime.\ngap_end: Time of the access end [UTC] encoded using DateTime.\nduration: Duration of the access [s].\nThe unit of the column duration is stored in the DataFrame using metadata.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> jd₀ = date_to_jd(2024, 1, 1);\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       );\n\njulia> orbp = Propagators.init(Val(:J2), orb);\n\njulia> ground_facility_gaps(orbp, (0, 0, 0))\n3×3 DataFrame\n Row │ gap_beginning            gap_end                  duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T00:00:00      2024-01-01T10:20:03.136  37203.1\n   2 │ 2024-01-01T10:30:02.971  2024-01-01T22:49:55.910  44392.9\n   3 │ 2024-01-01T22:59:23.470  2024-01-02T00:00:00       3636.53\n\njulia> ground_facility_gaps(orbp, (0, 0, 0); unit = :m)\n3×3 DataFrame\n Row │ gap_beginning            gap_end                  duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T00:00:00      2024-01-01T10:20:03.136  620.052\n   2 │ 2024-01-01T10:30:02.971  2024-01-01T22:49:55.910  739.882\n   3 │ 2024-01-01T22:59:23.470  2024-01-02T00:00:00       60.6088\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_facility_visibility_circle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Tuple{T1, T2, T3}, Number}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_facility_visibility_circle","text":"ground_facility_visibility_circle(gf_wgs84::Tuple, satellite_position_norm::Number; kwargs...) -> Vector{NTuple{2, Float64}}\n\nCompute the ground facility visibility circle from the position gf_wgs84 (WGS84) to a satellite in which its distance from the Earth's center is satellite_position_norm [m]. It returns a vector of NTuple{2, Float64} where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the visibility circle.\n\nThe ground facility is specified using a tuple with its WGS84 position:\n\n(latitude [rad], longitude [rad], altitude [m])\n\nKeywords\n\nazimuth_step::Number: The step in the azimuth used to compute the visibility circle.   (Default: 0.1 |> deg2rad)\nminimum_elevation::Number: Minimum elevation angle for communication between the   satellite and the ground facility [rad].   (Default: 10 |> deg2rad)\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis, UnicodePlots\n\njulia> gfv = ground_facility_visibility_circle((0, 0, 0), EARTH_EQUATORIAL_RADIUS + 700e3);\n\njulia> lineplot(last.(gfv) .|> rad2deg, first.(gfv) .|> rad2deg; xlim = (-180, 180), ylim = (-90, 90))\n       ┌────────────────────────────────────────┐ \n    90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡼⠉⡏⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⡧⠤⡧⢼⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⣀⣇⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   -90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       └────────────────────────────────────────┘ \n       ⠀-180⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀180⠀ \n\njulia> gfv = ground_facility_visibility_circle((-40 |> deg2rad, -60 |> deg2rad, 700), EARTH_EQUATORIAL_RADIUS + 700e3);\n\njulia> lineplot(last.(gfv) .|> rad2deg, first.(gfv) .|> rad2deg; xlim = (-180, 180), ylim = (-90, 90))\n       ┌────────────────────────────────────────┐ \n    90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠒⢦⡀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⢹⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣄⠀⠀⠀⣸⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠒⠋⠁⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   -90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       └────────────────────────────────────────┘ \n       ⠀-180⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀180⠀ \n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_repeating_orbit_adjacent_track_angle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_repeating_orbit_adjacent_track_angle","text":"ground_repeating_orbit_adjacent_track_angle(a::T1, e::T2, i::T3, orbit_cycle::Integer; kwargs...) where {T1 <: Number, T2 <: Number, T3 <: Number}\n\nCompute the adjacent track angle [rad] at Equator in a ground repeating orbit measured from the satellite position. The orbit is described by its semi-major axis a [m], eccentricity [ ], inclination i [rad], and orbit cycle orbit_cyle [day].\n\nwarning: Warning\nThe code does not check if the orbit is ground-repeating with orbit_cycle [day].\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1, T2, and T3 to a float-pointing number T.\n\nKeywords\n\nperturbation::Symbol: Symbol to select the perturbation terms that will be used. It can   be :J0, :J2, or :J4.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default: GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default: EGM_2008_J2)\nJ4::Number: J₄ perturbation term.   (Default: EGM_2008_J4)\nR0::Number: Earth's equatorial radius [m].   (Default: EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)\n\nExtended help\n\nA ground repeating orbit is any orbit that the number of revolutions per day is a rational number. Hence, this type of orbit repeats its ground trace after a finite number of days.\n\nThe information orbit_cyle is redundant given that we have a, e, and i. However, it is necessary to improve the algorithm precision. Otherwise, the orbit_cycle must be obtained by computing the orbit period using a, e, and i and then converting it to a rational number, leading to numerical problems.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_repeating_orbit_adjacent_track_distance-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_repeating_orbit_adjacent_track_distance","text":"ground_repeating_orbit_adjacent_track_distance(orbit_period::T1, i::T2, orbit_cycle::Integer; kwargs...) where {T1 <: Number, T2 <: Number} -> T\n\nCompute the adjacent track distance [m] at Equator in a ground repeating orbit.  The orbit is described by its orbital period orbit_period [s], inclination i [rad], and orbit cycle orbit_cycle [day].\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nperturbation::Symbol: Symbol to select the perturbation terms that will be used. It can   be :J0, :J2, or :J4.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default: GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default: EGM_2008_J2)\nJ4::Number: J₄ perturbation term.   (Default: EGM_2008_J4)\nR0::Number: Earth's equatorial radius [m].   (Default: EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)\n\nExtended help\n\nA ground repeating orbit is any orbit that the number of revolutions per day is a rational number. Hence, this type of orbit repeats its ground trace after a finite number of days.\n\nThe information orbit_period and orbit_cyle is redundant. However, they are necessary to improve the algorithm precision. Otherwise, the orbit_cycle must be obtained by converting the floating-point number orbit_period to a rational number, leading to numerical problems.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_track-Tuple{OrbitPropagator}","page":"Library","title":"SatelliteAnalysis.ground_track","text":"ground_track(orbp::OrbitPropagator; kwargs...) -> Vector{NTuple{2, Float64}}\n\nCompute the satellite ground track using the orbit propagator orbp. It returns a vector of NTuple{2, Float64} where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the ground track.\n\nKeywords\n\nadd_nans::Bool: If true, we add NaN if there is a discontinuity in the ground track   to improve plotting.   (Default: true)\nduration::Number: Duration of the analysis.   (Default: 86400)\ninitial_time::Number: Initial time regarding the orbit propagator orbp epoch [s].   (Default: 0)\nf_eci_to_ecef::Function: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be\nf_eci_to_ecef(r_i::AbstractVector, jd::Number) -> AbstractVector\nand it must return the position vector r_i represented in the ECEF at the instant jd   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (Default: _ground_track_default_eci_to_ecef)\nstep::Union{Nothing, Number}: Step for the computation. If nothing, we will roughly   compute the step to approximate 1° in the mean anomaly.   (Default: nothing)\ntrack_types::Symbol: A symbol describing what kind of track types we must add to the   output vector. It can be :ascending for only ascending passages, :descending for   only descending passages, or :all for both.   (Default: :all)\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis, UnicodePlots\n\njulia> jd₀ = date_to_jd(2024, 1, 1);\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       );\n\njulia> orbp = Propagators.init(Val(:J2), orb);\n\njulia> gt = ground_track(orbp);\n\njulia> lineplot(last.(gt), first.(gt))\n      ┌────────────────────────────────────────┐\n    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⣸⡿⠿⣻⠿⣿⠿⣟⡯⢟⡿⢿⣿⡿⣿⡟⣿⡿⢿⣿⢿⣿⢻⣿⠿⣿⡟⣿⡿⣿⡿⢿⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠞⠹⡼⠙⣶⠋⢶⠋⢣⠏⢳⡞⠀⣿⡁⡽⡇⣹⡇⢨⢏⢈⢯⠀⣿⡀⡽⡁⣹⡇⢸⣯⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢦⢰⢳⢠⢿⡀⡟⡄⡞⡇⡸⣇⢸⠁⢷⠃⣷⡇⢸⡏⠸⡼⠈⣾⠀⣷⠃⢣⠇⢹⣏⠏⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢸⡞⠘⣾⠀⣿⠁⢧⠃⢹⡇⢸⡏⠀⣼⠀⣿⡆⢰⡇⢀⣇⠀⣷⠀⣾⠀⣸⡀⢸⣿⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢀⡇⠀⣇⠀⣿⠀⢸⠀⢸⡁⢨⡇⠀⡇⡇⡏⡇⣸⢳⢸⢸⢰⢻⣀⡏⡆⡇⡇⡜⣯⠀⠀⠀⠀⠀│\n      │⠤⠤⠤⠤⢼⢧⢤⢿⠤⣿⠤⡿⡦⡼⡧⢼⣧⢴⠥⢧⡧⢼⡧⢼⡾⠼⣼⠤⣿⠤⣧⠧⢷⣧⢿⠤⠤⠤⠤⠤│\n      │⠀⠀⠀⠀⡼⢸⢸⠸⣼⠁⣇⠇⡇⡇⢳⡞⢸⢸⠀⢸⡇⢸⡇⠈⡇⠀⡏⠀⣿⠀⢸⠀⢸⢹⠘⡆⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠁⠈⡏⠀⡿⠀⢿⠀⢹⠃⢸⡇⠘⡇⠀⡜⡇⣸⡇⢸⢧⢠⢿⠀⣿⠀⡾⡄⡸⡟⠀⣷⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢆⢰⢳⢀⢿⠀⡿⡄⡼⡆⣸⣇⢰⢧⢠⠇⣧⡇⢹⡞⠸⡼⠘⣾⠁⣷⠃⢧⢧⢷⢀⡟⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢘⣎⢈⣞⠀⣿⡁⣳⡃⣹⡇⢸⣏⢘⣞⢀⡿⢆⡼⢧⣰⢳⣠⠿⣀⠾⣄⡞⣆⢈⣿⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢹⣾⣿⣾⣿⣶⣿⣧⣿⣷⣿⣷⣾⣿⣼⣿⣷⣾⣷⣾⣵⣲⣽⣶⣿⣶⣯⣶⣼⣿⣾⣿⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      └────────────────────────────────────────┘\n      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀\n\njulia> gt = ground_track(orbp, track_types = :ascending);\n\njulia> lineplot(last.(gt), first.(gt))\n      ┌────────────────────────────────────────┐\n    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢸⡛⠽⡛⠿⣟⠫⣟⠫⢍⠛⠻⢿⡻⢽⡛⡿⡛⠿⣟⠯⣟⠫⢟⠻⢿⡛⢽⡛⠽⡛⠯⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠹⡄⠘⡆⠈⢆⠈⢣⠀⢳⡀⠀⢳⡀⠹⡇⠙⡆⠈⢆⠈⢧⠀⢳⡀⠱⡀⠙⡄⠘⣆⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢦⠀⢱⠀⢸⡀⠘⡄⠈⡇⠀⣇⠀⠀⢧⠀⣷⠀⢸⠀⠸⡄⠈⡆⠀⣇⠀⢣⠀⢹⠀⠈⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢸⡀⠘⡆⠀⡇⠀⢇⠀⢹⠀⢸⠀⠀⢸⠀⡟⡆⠀⡇⠀⣇⠀⢳⠀⢸⠀⠸⡀⠈⡇⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⡇⠀⣇⠀⢳⠀⢸⠀⠸⡀⠈⡇⠀⠀⡇⡇⡇⠀⢳⠀⢸⠀⢸⡀⠈⡆⠀⡇⠀⢧⠀⠀⠀⠀⠀│\n      │⠤⠤⠤⠤⠤⢧⠤⢼⠤⢼⠤⠼⡦⠤⡧⠤⣧⠤⠤⢧⡧⢼⠤⢼⠤⠼⡤⠤⡧⠤⡧⠤⢷⠤⢼⠤⠤⠤⠤⠤│\n      │⠀⠀⠀⠀⠀⢸⠀⠸⡄⠀⡇⠀⡇⠀⢳⠀⢸⠀⠀⢸⡇⠸⡄⠈⡇⠀⡇⠀⢧⠀⢸⠀⢸⠀⠘⡆⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠈⡇⠀⡇⠀⢧⠀⢹⠀⢸⡀⠘⡆⠀⠘⡇⠀⡇⠀⢧⠀⢹⠀⢸⠀⠸⡄⠈⡇⠀⣇⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢆⠀⢳⠀⢸⠀⠸⡄⠘⡆⠀⣇⠀⢧⠀⠀⣧⠀⢹⠀⠸⡀⠘⡆⠀⣇⠀⢧⠀⢳⠀⠘⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠘⣆⠈⢆⠀⢧⡀⢳⡀⠹⡄⠘⣄⠘⣆⠀⡏⢆⠀⢧⠀⢳⡀⠹⡀⠸⣄⠘⣆⠈⢧⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠐⣬⣗⣮⣷⣦⣵⣢⣽⣲⣽⣶⣬⣗⣬⣗⣧⣬⣓⣦⣵⣢⣽⣲⣽⣶⣬⣖⣬⣗⣮⡵⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      └────────────────────────────────────────┘\n      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀\n\njulia> gt = ground_track(orbp, track_types = :descending);\n\njulia> lineplot(last.(gt), first.(gt))\n      ┌────────────────────────────────────────┐\n    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⣸⡽⠟⣻⠽⣻⠿⢛⡯⢛⡯⢟⡻⠝⣻⠝⣿⠽⢛⠯⢛⡯⢛⡿⠟⡻⠝⣻⠽⣻⠿⢓⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠞⠀⡼⠁⣰⠃⢰⠋⢠⠏⢀⡞⠀⡜⠁⡼⡇⣰⠃⢠⠏⢀⠎⠀⡞⠀⡼⠁⣰⠃⢰⣫⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⢰⠃⢠⠇⠀⡏⠀⡞⠀⡸⠀⢸⠁⢰⠃⣇⡇⠀⡏⠀⡼⠀⣸⠀⢰⠃⢠⠇⠀⣏⠇⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⡞⠀⣸⠀⢸⠁⢠⠃⠀⡇⠀⡏⠀⡼⠀⣿⠀⢰⠁⢀⡇⠀⡇⠀⡞⠀⣸⠀⢸⢸⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢀⡇⠀⡇⠀⡜⠀⢸⠀⢸⠁⢠⠇⠀⡇⠀⡏⠀⣸⠀⢸⠀⢰⠃⢀⡇⠀⡇⠀⡜⡏⠀⠀⠀⠀⠀│\n      │⠤⠤⠤⠤⢼⠤⢤⠧⠤⡧⠤⡯⠤⡼⠤⢼⠤⢴⠥⢤⡧⠤⡧⠤⡾⠤⢼⠤⢼⠤⢤⠧⠤⣧⠧⠤⠤⠤⠤⠤│\n      │⠀⠀⠀⠀⡼⠀⢸⠀⢸⠁⢀⠇⠀⡇⠀⡞⠀⢸⠀⢸⡇⢠⠃⠀⡇⠀⡏⠀⡼⠀⢸⠀⢸⢹⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠁⠀⡎⠀⡸⠀⢸⠀⢰⠃⢀⡇⠀⡇⠀⡜⡇⣸⠀⢸⠁⢠⠇⠀⡇⠀⡎⠀⡸⡞⠀⣰⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⢰⠃⢀⠇⠀⡏⠀⡼⠀⣸⠀⢰⠁⢠⠇⣇⡇⠀⡞⠀⡼⠀⢸⠁⢰⠃⢀⢧⠇⢀⡇⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢀⠎⢀⡞⠀⡼⠁⡰⠃⣠⠃⢠⠏⢀⡞⢀⡿⠀⡼⠁⣰⠃⢠⠇⢀⠎⢀⡞⠀⢀⡜⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢩⣖⣯⣔⣮⣴⣾⣥⣺⣥⣲⣥⣖⣯⣔⣯⣷⣾⣵⣺⣥⣲⣥⣶⣯⣖⣋⣤⣔⣯⣔⣎⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      └────────────────────────────────────────┘\n      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_track_inclination-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_track_inclination","text":"ground_track_inclination(a::Number, e::Number, i::Number; kwargs...) -> T\nground_track_inclination(orb::Orbit{Tepoch, T}); kwargs...) where {Tepoch <: Number, T <: Number} -> T\n\nCompute the ground track inclination at the Equator [rad] in an orbit with semi-major axis a [m], eccentricity e [ ], and inclination i [rad]. The orbit can also be specified by orb (see Orbit).\n\nnote: Note\nThe output type T in the first signature is obtained by promoting the inputs to a float type.\n\nwarning: Warning\nThe algorithm here assumes a small orbit eccentricity.\n\nKeywords\n\nperturbation::Symbol: Symbol to select the perturbation terms that will be used. It can   be :J0, :J2, or :J4.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default: GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default: EGM_2008_J2)\nJ4::Number: J₄ perturbation term.   (Default: EGM_2008_J4)\nR0::Number: Earth's equatorial radius [m].   (Default: EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)\n\nExtended Help\n\nWe define the ground track inclination as the angle that the ground track has with respect to the Equator. This information is important to compute, for example, the required swath for a remote sensing satellite to cover the entire Earth.\n\nThe ground track inclination i_gt is given by:\n\n            ┌                       ┐\n            │      ω_s ⋅ sin i      │\ni_gt = atan │ ───────────────────── │\n            │ ω_s ⋅ cos i - ω_e + Ω̇ │\n            └                       ┘\n\nwhere ω_s = n + ω̇ is the satellite angular velocity, n is the perturbed mean motion, i is the orbit inclination, ω is the orbit argument of perigee, Ω is the orbit right ascension of the ascending node, and ω_e is the Earth's angular rate.\n\nFormally, we should use the satellite instantaneous angular speed at the Equator instead of the mean angular speed ω_s. However, given the perturbations caused by the Earth's gravitational potential, the former is not simple to compute. This calculation would required to implement an orbit propagator here. Thus, we simplify it by assuming that the orbit eccentricity is small. This assumption is reasonable given the missions that would benefit from the computation of the ground track inclination. In this case, the orbit angular speed is almost constant and equal to ω_s.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> ground_track_inclination(7130.982e3, 0.00111, 98.410 |> deg2rad) |> rad2deg\n102.30052101661899\n\njulia> jd₀ = date_to_jd(2021, 1, 1)\n2.4592155e6\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.410 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45922e6 (2021-01-01T00:00:00)\n Semi-major axis : 7130.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.41     °\n            RAAN :   78.4021   °\n Arg. of Perigee :   90.0      °\n    True Anomaly :    0.0      °\n\njulia> ground_track_inclination(orb) |> rad2deg\n102.30052101658998\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.is_ground_facility_visible-Tuple{AbstractVector, AbstractVector, Number}","page":"Library","title":"SatelliteAnalysis.is_ground_facility_visible","text":"is_ground_facility_visible(sat_r_e::AbstractVector, gf_r_e::AbstractVector, θ::Number) -> Bool\n\nCheck if the satellite with position vector sat_r_e (ECEF) is inside the visibility circle of a ground facility with position vector gf_r_e (ECEF) and a minimum elevation angle of θ [rad].\n\nNotice that sat_r_e and gf_r_e must be represented in the same ECEF frame, and must have the same unit.\n\nReturns\n\nBool: true if the satellite is inside the visibility circle, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.is_ground_facility_visible-Tuple{AbstractVector, Vararg{Number, 4}}","page":"Library","title":"SatelliteAnalysis.is_ground_facility_visible","text":"is_ground_facility_visible(sat_r_e::AbstractVector, gf_lat::Number, gf_lon::Number, gf_h::Number, θ::Number) -> Bool\n\nCheck if the satellite with position vector sat_r_e (ECEF) is inside the visibility circle of a ground facility with latitude gf_lat [rad], longitude gf_lon [rad], altitude gf_h (WGS-84), and a minimum elevation angle of θ [rad].\n\nNotice that sat_r_e and gf_h must have the same units.\n\nReturns\n\nBool: true if the satellite is inside the visibility circle, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.lighting_condition-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"SatelliteAnalysis.lighting_condition","text":"lighting_condition(r_i::AbstractVector, s_i::AbstractVector)\n\nCompute the lighting condition at the position r_i [m] considering the Sun position vector s_i [m]. The possible return values are:\n\n:sunlight: The point is under direct sunlight.\n:penumbra: The point is in penumbra region.\n:umbra: The point is in umbra region.\n\nThe algorithm used in this function was based on [1].\n\nnote: Note\nThe vectors r_i and s_i must be represented in the same reference frame.\n\nReferences\n\n[1] Longo, C. R. O., Rickman, S. L (1995). Method for the Calculation of Spacecraft   Umbra and Penumbra Shadow Terminator Points. NASA Technical Paper 3547.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.plot_ground_facility_visibility_circles-Tuple","page":"Library","title":"SatelliteAnalysis.plot_ground_facility_visibility_circles","text":"plot_ground_facility_visibility_circles(vgf_vc::Vector{Vector{NTuple{2, T}}}; kwargs...) where T <: Number -> Figure, Axis\n\nPlot the ground facility visibility circles in the vector vgf_vc, where each element is computed using the function ground_facility_visibility_circle. It returns the objects Figure and Axis used to plot the data. For more information, please, refer to Makie.jl documentation.\n\nwarning: Warning\nThis function only works after loading the package GeoMakie.jl. Furthermore, the user must also load one Makie.jl back end (CairoMakie.jl or GLMakie.jl, for example) to see the result.\n\nKeywords\n\nground_facility_names::Union{Nothing, Vector{String}}: The user can provide a vector of   Strings with the length of vgf_vc to be plotted with the visibility circles. If this   parameter is nothing, no ground facility name is added to the figure.   (Default = nothing)\n\nAll other kwargs... are passed to the function Figure.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis, GeoMakie, GLMakie\n\njulia> gfv1 = ground_facility_visibility_circle((0, 0, 0), EARTH_EQUATORIAL_RADIUS + 700e3);\n\njulia> gfv2 = ground_facility_visibility_circle((-40 |> deg2rad, -60 |> deg2rad, 0), EARTH_EQUATORIAL_RADIUS + 700e3);\n\njulia> fig, ax = plot_ground_facility_visibility_circles(\n           [gfv1, gfv2];\n           ground_facility_names = [\"GF 1\", \"GF 2\"]\n       )\n(Scene (1600px, 800px):\n  0 Plots\n  1 Child Scene:\n    └ Scene (1600px, 800px), Axis (7 plots))\n\njulia> fig\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.plot_ground_track-Tuple{Any}","page":"Library","title":"SatelliteAnalysis.plot_ground_track","text":"plot_ground_track(gt::Vector{NTuple{2, T}}; kwargs...) where T<:Number -> Figure, Axis\n\nPlot the ground track gt computed using the function ground_track. It returns the objects Figure and Axis used to plot the data. For more information, please, refer to Makie.jl documentation.\n\nwarning: Warning\nThis function only works after loading the package GeoMakie.jl. Furthermore, the user must also load one Makie.jl back end (CairoMakie.jl or GLMakie.jl, for example) to see the result.\n\nAll kwargs... are passed to the function Figure.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis, GeoMakie, GLMakie\n\njulia> jd₀ = date_to_jd(2021, 1, 1)\n2.4592155e6\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45922e6 (2021-01-01T00:00:00)\n Semi-major axis : 7130.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   78.4021   °\n Arg. of Perigee :   90.0      °\n    True Anomaly :    0.0      °\n\njulia> orbp = Propagators.init(Val(:J2), orb)\nOrbitPropagatorJ2{Float64, Float64}:\n   Propagator name : J2 Orbit Propagator\n  Propagator epoch : 2021-01-01T00:00:00\n  Last propagation : 2021-01-01T00:00:00\n\njulia> gt = ground_track(orbp; track_types = :descending, duration = 5 * 86400);\n\njulia> fig, ax = plot_ground_track(gt; size = (2000, 1000))\n(Scene (2000px, 1000px):\n  0 Plots\n  1 Child Scene:\n    └ Scene (2000px, 1000px), Axis (2 plots))\n\njulia> fig\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.sun_sync_orbit_from_angular_velocity-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Library","title":"SatelliteAnalysis.sun_sync_orbit_from_angular_velocity","text":"sun_sync_orbit_from_angular_velocity(angvel::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, T, Bool\n\nCompute the Sun-synchronous orbit semi-major axis [m] and inclination [rad] given the angular velocity angvel [rad / s] and the orbit eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.\n\nThe algorithm here considers only the perturbation terms up to J₂.\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nmax_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 3)\nno_warnings::Bool: If true, no warnings will be printed.   (Default = false)\ntolerance::Union{Nothing, NTuple{2, Number}}: Residue tolerances to verify if the   numerical method has converged. If it is nothing, (√eps(T), √eps(T)) will be used,   where T is the internal type for the computations. Notice that the residue function   f₁ unit is [deg / day], whereas the f₂ unit is [deg / min].   (Default = 1e-18)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\nReturns\n\nT: Semi-major axis [m].\nT: Inclination [rad].\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.\n\nExtended help\n\nA Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth's orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.\n\nThe RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:\n\n∂Ω      3                       n̄\n── = - ─── R₀² . J₂ . cos(i) . ─── .\n∂t      2                       p²\n\nwhere:\n\n         ┌                                                ┐\n         │      3    R₀²                                  │\nn̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.\n         │      4     p²                                  │\n         └                                                ┘\n\nWe can express the orbit angular velocity in terms of its nodal period, i.e., the period it takes for the satellite to cross the ascending node two consecutive times:\n\n          ∂M     ∂ω\nangvel = ──── + ────,\n          ∂t     ∂t\n\n                  3    R₀²\nangvel = n̄ + n̄ . ─── . ─── . J₂ . (4 - 5sin²(i)),\n                  4     p²\n\nwhere n is the perturbed mean motion due to the same consideration as presented for the RAAN time-derivative.\n\nFinally, this function finds the pair (a, i) that simultaneously solves the equations:\n\n∂Ω\n── (a, i) = EARTH_ORBIT_MEAN_MOTION,\n∂t\n\n ∂M            ∂ω\n──── (a, i) + ──── (a, i) = angvel,\n ∂t            ∂t\n\nusing the Newton-Raphson method with the presented equations.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad)\n(7.130983932846816e6, 1.7175898375139984, true)\n\njulia> sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad, 0)\n(7.130983932846816e6, 1.7175898375139984, true)\n\njulia> sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad, 0.1)\n(7.13086251587883e6, 1.7146410689929386, true)\n\nThe user can verify some internal information of the solver by turning on the debugging logs:\n\njulia> with_logger(ConsoleLogger(stderr, Logging.Debug)) do\n           sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad)\n       end\n┌ Debug: Iteration #1\n│   Estimation :\n│     a  = 7136.635455699327 km\n│     i  = 81.57099271530629 °\n│   Residues :\n│     f₁ = 1.9706966881670205 ° / day\n│     f₂ = 0.004266929859281898 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n┌ Debug: Iteration #2\n│   Estimation :\n│     a  = 7128.856266265137 km\n│     i  = 98.46515928332974 °\n│   Residues :\n│     f₁ = -0.0073785260175135425 ° / day\n│     f₂ = -0.0016144146737784304 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n┌ Debug: Iteration #3\n│   Estimation :\n│     a  = 7130.983594940013 km\n│     i  = 98.41070350863473 °\n│   Residues :\n│     f₁ = -6.549620124363109e-6 ° / day\n│     f₂ = -2.6066638092459016e-7 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n┌ Debug: Iteration #4\n│   Estimation :\n│     a  = 7130.983932846698 km\n│     i  = 98.41064862339992 °\n│   Residues :\n│     f₁ = 8.290634845309341e-11 ° / day\n│     f₂ = -2.2648549702353193e-14 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n(7.130983932846816e6, 1.7175898375139984, true)\n\nReferences\n\n[1] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.sun_sync_orbit_inclination-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Library","title":"SatelliteAnalysis.sun_sync_orbit_inclination","text":"sun_sync_orbit_inclination(a::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, Bool\n\nCompute the inclination [rad] of the Sun-synchronous orbit with semi-major axis a [m] and the eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.\n\nThe algorithm here considers only the perturbation terms up to J₂.\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nmax_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 30)\ntolerance::Union{Nothing, Number}: Residue tolerance to verify if the numerical method   has converged. If it is nothing, √eps(T) will be used, where T is the internal   type for the computations. Notice that the residue unit is [deg / day].   (Default = nothing)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\nReturns\n\nT: Inclination [rad] of the Sun-synchronous orbit with semi-major axis a and   eccentricity e.\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.\n\nExtended help\n\nA Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth's orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.\n\nThe RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:\n\n∂Ω      3                       n̄\n── = - ─── R₀² . J₂ . cos(i) . ─── .\n∂t      2                       p²\n\nwhere:\n\n         ┌                                                ┐\n         │      3    R₀²                                  │\nn̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.\n         │      4     p²                                  │\n         └                                                ┘\n\nFinally, this function solves the equation:\n\n∂Ω\n── (i) = EARTH_ORBIT_MEAN_MOTION\n∂t\n\nfor i using the Newton-Raphson method with the presented equations.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> sun_sync_orbit_inclination(7130.982e3)\n(1.7175896973066611, true)\n\njulia> sun_sync_orbit_inclination(7130.982e3, 0)\n(1.7175896973066611, true)\n\njulia> sun_sync_orbit_inclination(7130.982e3, 0.001111)\n(1.7175893324980402, true)\n\nThe user can verify some internal information of the solver by turning on the debugging logs:\n\njulia> with_logger(ConsoleLogger(stderr, Logging.Debug)) do\n           sun_sync_orbit_inclination(7130.982e3)\n       end\n┌ Debug: Iteration #1\n│   Estimation : 98.41064059121584 °\n│   Residue    : 0.0005992085524891833 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:686\n┌ Debug: Iteration #2\n│   Estimation : 98.41064059082426 °\n│   Residue    : -4.556321986370904e-11 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:686\n(1.7175896973066611, true)\n\nReferences\n\n[1] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.sun_sync_orbit_semi_major_axis-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Library","title":"SatelliteAnalysis.sun_sync_orbit_semi_major_axis","text":"sun_sync_orbit_semi_major_axis(i::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, Bool\n\nCompute the semi-major axis [m] of the Sun-synchronous orbit with inclination i [rad] and the eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.\n\nThe algorithm here considers only the perturbation terms up to J₂.\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nmax_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 30)\ntolerance::Union{Nothing, Number}: Residue tolerance to verify if the numerical method   has converged. If it is nothing, √eps(T) will be used, where T is the internal   type for the computations. Notice that the residue unit is [deg / day].   (Default = nothing)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\nReturns\n\nT: Semi-major axis [m] of the Sun-synchronous orbit with inclination i and   eccentricity e.\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.\n\nExtended help\n\nA Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth's orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.\n\nThe RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:\n\n∂Ω      3                       n̄\n── = - ─── R₀² . J₂ . cos(i) . ─── .\n∂t      2                       p²\n\nwhere:\n\n         ┌                                                ┐\n         │      3    R₀²                                  │\nn̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.\n         │      4     p²                                  │\n         └                                                ┘\n\nFinally, this function solves the equation:\n\n∂Ω\n── (a) = EARTH_ORBIT_MEAN_MOTION\n∂t\n\nfor a using the Newton-Raphson method with the presented equations.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> sun_sync_orbit_semi_major_axis(98.410 |> deg2rad)\n(7.130827866508738e6, true)\n\njulia> sun_sync_orbit_semi_major_axis(98.410 |> deg2rad, 0)\n(7.130827866508738e6, true)\n\njulia> sun_sync_orbit_semi_major_axis(98.410 |> deg2rad, 0.001111)\n(7.1308328955274355e6, true)\n\nThe user can verify some internal information of the solver by turning on the debugging logs:\n\njulia> with_logger(ConsoleLogger(stderr, Logging.Debug)) do\n           sun_sync_orbit_semi_major_axis(98.41064163374567 |> deg2rad)\n       end\n┌ Debug: Iteration #1\n│   Estimation : 7130.981820550704 km\n│   Residue    : 0.0005989504045072862 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559\n┌ Debug: Iteration #2\n│   Estimation : 7130.982250931794 km\n│   Residue    : -2.081337784770338e-7 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559\n┌ Debug: Iteration #3\n│   Estimation : 7130.982250931845 km\n│   Residue    : -2.4312691616901194e-14 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559\n(7.130982250931845e6, true)\n\nReferences\n\n[1] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.\n\n\n\n\n\n","category":"method"},{"location":"man/beta_angle/#Beta-Angle","page":"Beta Angle","title":"Beta Angle","text":"","category":"section"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"using SatelliteAnalysis","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The beta angle is the angle between the orbit plane and the Sun, as shown in the following figure. The positive direction is defined as that of the orbit angular momentum.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The beta angle is useful when computing the mean amount of solar radiation a satellite receives in a particular orbit.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"<div align=\"center\">\n  <img src=\"../../assets/beta_angle.png\" alt=\"Beta Angle\" width=\"50%\"/>\n</div>","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"We can compute the beta angle of an orbit using the function:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"beta_angle(orb::KerplerianElements{Tepoch, T}, Δjd::Number; kwargs...) -> Float64","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"This function computes the beta angle [rad] for the orbit orb after Δjd days from its epoch.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The algorithm was obtained from [1].","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"note: Note\nIt is expected that the input elements are represented in the TOD reference frame. If it is not the case, they can be converted using the function orb_eci_to_eci of SatelliteToolboxTransformations.jl.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The following keywords are available:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"perturbation::Symbol: Select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J₂.\n:J4: Consider the perturbation terms J₂, J₂², and J₄.\n(Default: :J2)","category":"page"},{"location":"man/beta_angle/#Examples","page":"Beta Angle","title":"Examples","text":"","category":"section"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"We will compute the beta angle of the Amazonia-1 mission for one year. The first thing we need to do is define the orbit:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"jd₀ = date_to_jd(2021, 1, 1)\n\norb = KeplerianElements(\n    jd₀,\n    7130.982e3,\n    0.001111,\n    98.405 |> deg2rad,\n    ltdn_to_raan(10.5, jd₀),\n    π / 2,\n    0\n)","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"Now, we can use the function beta_angle to obtain the beta angle [rad] for each day of the year:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"β = beta_angle.(orb, 1:365)","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"If we use CairoMakie.jl to plot, we obtain:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"using CairoMakie\n\nfig = Figure(; size = (1000, 800))\n\nax = Axis(\n    fig[1, 1],\n    spinewidth         = 2,\n    title              = \"Amazonia-1 Beta Angle\",\n    titlegap           = 16,\n    titlesize          = 30,\n    xlabelsize         = 30,\n    xticklabelsize     = 26,\n    xticks             = 0:11,\n    xtickformat        = y -> map(m -> Dates.monthname(Int(m + 1))[1:3], y),\n    xticklabelrotation = pi / 4,\n    ylabel             = \"Beta Angle [°]\",\n    ylabelsize         = 30,\n    yticklabelsize     = 26,\n    yticks             = 17:27\n)\n\nxlims!(ax, 0, 12)\n\nlines!(ax, collect(1:365) ./ 30, β .|> rad2deg; linewidth = 4)\n\nsave(\"amz1_beta_angle.png\", fig)","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"(Image: Amazonia-1 beta angle)","category":"page"},{"location":"man/beta_angle/#References","page":"Beta Angle","title":"References","text":"","category":"section"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"[1]: Mortari, D., Wilkins, M. P., and Bruccoleri, C. On Sun-Synchronous Orbits and Associated Constellations.","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/#Ground-Facility-Visibility-Circle","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"using SatelliteAnalysis","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"We can use the function:","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"ground_facility_visibility_circle(gf_wgs84::Tuple, satellite_position_norm::Number; kwargs...) -> Vector{NTuple{2, Float64}}","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"to compute the ground facility visibility circle from the position gf_wgs84 (WGS84) to a satellite in which its distance from the Earth's center is satellite_position_norm [m]. It returns a vector of NTuple{2, Float64} where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the visibility circle.","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"The ground facility is specified using a tuple with its WGS84 position:","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"(latitude [rad], longitude [rad], altitude [m])","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"The following keywords are available:","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"azimuth_step::Number: The step in the azimuth used to compute the visibility circle.   (Default: 0.1 |> deg2rad)\nminimum_elevation::Number: Minimum elevation angle for communication between the   satellite and the ground facility [rad].   (Default: 10 |> deg2rad)","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"note: Note\nIf we want to verify if a satellite has line-of-sight to a ground facility, see the function is_ground_facility_visible.","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/#Examples","page":"Ground Facility Visibility Circle","title":"Examples","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"We can obtain the visibility circle between the Amazonia-1 satellite and INPE's ground station at Cuiabá, MT, Brazil, using:","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"using SatelliteAnalysis, GeoMakie, CairoMakie\n\ngf = ground_facility_visibility_circle(\n    (-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0),\n    7130.982e3\n)\n\ncountries_filename = fetch_country_polygons(; force_download = false)\n\ncountry_polys = GeoMakie.GeoJSON.read(read(countries_filename))\n\nfig = Figure(; size = (800, 800))\n\nax = Axis(\n    fig[1, 1],\n    aspect         = 1,\n    title          = \"Ground Facility Visibility\",\n    titlegap       = 16,\n    titlesize      = 30,\n    xlabel         = \"Longitude [°]\",\n    xlabelsize     = 30,\n    xticklabelsize = 26,\n    ylabel         = \"Latitude [°]\",\n    ylabelsize     = 30,\n    yticklabelsize = 26,\n)\n\nxlims!(ax, -95, -15)\nylims!(ax, -60, +20)\nax.xticks = -95:10:-15\nax.yticks = -60:10:20\n\npoly!(\n    ax,\n    country_polys;\n    color       = :white,\n    strokecolor = :black,\n    strokewidth = 1\n)\n\ngf_lat = first.(gf)\ngf_lon = last.(gf)\n\nvc = lines!(ax, gf_lon .|> rad2deg, gf_lat .|> rad2deg; linewidth = 2)\n\ndot = scatter!(ax, -(56 + 04 / 60), -(15 + 33 / 60))\ntranslate!(dot, 0, 0, 10)\n\nlabel = text!(\n    ax,\n    \"Cuiabá\";\n    fontsize = 26,\n    position = (-(56 + 04 / 60), -(15 + 33 / 60))\n)\ntranslate!(label, 0, 0, 10)\n\nsave(\"gf_visibility_circle_01.png\", fig)","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"ground_facility_visibility_circle(\n    (-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0),\n    7130.982e3\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"If we plot the result using Makie, we obtain:","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"(Image: Cuiabá ground facility visibility circle)","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/#Plotting","page":"Ground Facility Visibility Circle","title":"Plotting","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"If the user loads the package GeoMakie.jl together with a Makie.jl back end, an extension is loaded and adds the possibility to plot the ground facility visibility circle. In this case, the following function is available:","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"plot_ground_facility_visibility_circles(vgf_vc::Vector{Vector{NTuple{2, T}}}; kwargs...) where T <: Number -> Figure, Axis","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"It plots the ground facility visibility circles in the vector vgf_vc, where each element is computed using the function ground_facility_visibility_circle. It returns the objects Figure and Axis used to plot the data. For more information, please, refer to Makie.jl documentation.","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"The following keywords are available:","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"ground_facility_names::Union{Nothing, Vector{String}}: The user can provide a vector of   Strings with the length of vgf_vc to be plotted with the visibility circles. If this   parameter is nothing, no ground facility name is added to the figure.   (Default = nothing)","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"All other kwargs... are passed to the function Figure.","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/#Example","page":"Ground Facility Visibility Circle","title":"Example","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"The code:","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"using GeoMakie, CairoMakie\n\ngf1_vc = ground_facility_visibility_circle(\n    (-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0),\n    7130.982e3\n);\n\ngf2_vc = ground_facility_visibility_circle(\n    (-22.6763 |> deg2rad, -44.9973 |> deg2rad, 0),\n    7130.982e3\n);\n\ngf3_vc = ground_facility_visibility_circle(\n    (+78.228 |> deg2rad, +15.399 |> deg2rad, 0),\n    7130.982e3\n);\n\nfig, ax = plot_ground_facility_visibility_circles(\n    [gf1_vc, gf2_vc, gf3_vc];\n    ground_facility_names = [\"Cuiabá\", \"Cachoeira Paulista\", \"Svalbard\"]\n);\n\nsave(\"gf_visibility_circle_02.png\", fig)","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"produces the following figure:","category":"page"},{"location":"man/ground_facilities/ground_facility_visibility_circle/","page":"Ground Facility Visibility Circle","title":"Ground Facility Visibility Circle","text":"(Image: Ground facility visibility circles)","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/#Sun-Synchronous-Orbits","page":"Sun Synchronous Orbits","title":"Sun-Synchronous Orbits","text":"","category":"section"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"using SatelliteAnalysis","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Given the Earth's gravitational potential, all the low Earth orbits (LEO) suffer from perturbations in their elements. The right ascension of the ascending node (RAAN) is one of the elements that see a secular perturbation. Hence, we can use this effect to design orbits that the RAAN time derivative matches that of the Earth's orbit around the Sun. In this case, the orbit plane keeps its geometry almost constant regarding the Sun vector. Hence, the apparent local time of the ascending or descending node (LTAN and LTDN) will also be almost invariable, as shown in the following figure:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"<div align=\"center\">\n  <img src=\"../../../assets/sun_sync_orbit_plane.png\" alt=\"Orbit Plane in Sun-Synchronous Orbits\" width=\"100%\"/>\n</div>","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"In fact, if the Earth was a perfect sphere, no secular perturbation would be seen in RAAN. Hence, the LTAN would have a variation of 24 hours in a year.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Considering only terms up to J_2, which is the dominant effect, the RAAN time derivative is:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"fracdOmegadt = -frac23 J_2 left(fracR_0p_0right)^2 barn cos i_0 ","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"where R_0 is the Earth's Equatorial radius, i_0 is the orbit inclination, p_0 = a_0 (1 - e_0^2), a_0 is the orbit semi-major axis, and e_0 is the orbit eccentricity, and barn is the perturbed mean-motion, given by:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"barn = n_0 left1 + frac34 J_2 left(fracR_0p_0right)^2 sqrt1 - e_0^2 left(2 - 3sin^2 i_0right)right ","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"where n_0 = sqrtmu  a^3, and mu is the Earth's standard gravitational parameter.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"note: Note\nFormally, all quantities on the right-hand side of those equations must be the mean elements instead of the initial ones. However, we are considering only the secular perturbations caused by the J_2 term. Thus, the semi-major axis, eccentricity, and inclination do not suffer from secular effects.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Finally, we can design a Sun-syncrhonous orbit by selecting the semi-major axis and inclination that leads to:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"fracdOmegadt = 09856473598947981^circ  s ","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/#Designing-Sun-Synchronous-Orbits-from-Angular-Velocity","page":"Sun Synchronous Orbits","title":"Designing Sun-Synchronous Orbits from Angular Velocity","text":"","category":"section"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The satellite orbital angular velocity omega_o is:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"omega_o(a_0 i_0) = fracdMdt + fracdomegadt ","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"where M is the mean anomaly, and omega is the argument of perigee. Considering only the secular effects caused by the J_2 term, one gets:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"beginaligned\n  fracdMdt = barn  \n  fracdomegadt = frac34 J_2 left(fracR_0p_0right)^2 barn left(4 - 5sin^2 i_0right) \nendaligned","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Thus, given a desired angular velocity n_d, we can find the semi-major axis and inclination that leads to a Sun-synchronous orbit by numerically solving the system:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"beginaligned\n  fracdOmegadt(a_0 i_0) = 09856473598947981^circ  s  \n  barn(a_0 i_0) = n_d \nendaligned","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The function:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"sun_sync_orbit_from_angular_velocity(angvel::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, T, Bool","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"computes the Sun-synchronous orbit semi-major axis [m] and inclination [rad] given the angular velocity angvel [rad / s] and the orbit eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The algorithm here considers only the perturbation terms up to J_2.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"note: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The following keywords are available:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"max_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 3)\nno_warnings::Bool: If true, no warnings will be printed.   (Default = false)\ntolerance::Union{Nothing, NTuple{2, Number}}: Residue tolerances to verify if the   numerical method has converged. If it is nothing, (√eps(T), √eps(T)) will be used,   where T is the internal type for the computations. Notice that the residue function   f₁ unit is [deg / day], whereas the f₂ unit is [deg / min].   (Default = 1e-18)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"It returns:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"T: Semi-major axis [m].\nT: Inclination [rad].\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/#Example","page":"Sun Synchronous Orbits","title":"Example","text":"","category":"section"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Let's say we want to compute the Sun-synchronous orbit for a mission that must perform exactly 14 orbits per day:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"n_d = 14 * (2π / 86400)\na, i, converged = sun_sync_orbit_from_angular_velocity(n_d)\na / 1000\nrad2deg(i)","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/#Designing-Sun-Synchronous-Orbits-from-Semi-Major-Axis","page":"Sun Synchronous Orbits","title":"Designing Sun-Synchronous Orbits from Semi-Major Axis","text":"","category":"section"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Given a desired semi-major axis a_d, we can compute the inclination that turns the orbit into a Sun-synchronous one by solving numerically:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"fracdOmegadt(a_d i_0) = 09856473598947981^circ  s ","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The function:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"sun_sync_orbit_inclination(a::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, Bool","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"computes the inclination [rad] of the Sun-synchronous orbit with semi-major axis a [m] and the eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The algorithm here considers only the perturbation terms up to J_2.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"note: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The following keywords are available:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"max_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 30)\ntolerance::Union{Nothing, Number}: Residue tolerance to verify if the numerical method   has converged. If it is nothing, √eps(T) will be used, where T is the internal   type for the computations. Notice that the residue unit is [deg / day].   (Default = nothing)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"It returns:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"T: Inclination [rad] of the Sun-synchronous orbit with semi-major axis a and   eccentricity e.\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/#Example-2","page":"Sun Synchronous Orbits","title":"Example","text":"","category":"section"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Let's find the inclination that turns an orbit with semi-major axis 6819 km and eccentricity 0.0015 into a Sun-synchronous one:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"i, converged = sun_sync_orbit_inclination(6819e3, 0.0015)\nrad2deg(i)","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/#Designing-Sun-Synchronous-Orbits-from-Inclination","page":"Sun Synchronous Orbits","title":"Designing Sun-Synchronous Orbits from Inclination","text":"","category":"section"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Given a desired inclination i_d, we can compute the semi-major axis that turns the orbit into a Sun-synchronous one by solving numerically:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"fracdOmegadt(a_0 i_d) = 09856473598947981^circ  s ","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The function:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"sun_sync_orbit_semi_major_axis(i::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, Bool\n","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"compute the semi-major axis [m] of the Sun-synchronous orbit with inclination i [rad] and the eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The algorithm here considers only the perturbation terms up to J_2.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"note: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The following keywords are available:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"max_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 30)\ntolerance::Union{Nothing, Number}: Residue tolerance to verify if the numerical method   has converged. If it is nothing, √eps(T) will be used, where T is the internal   type for the computations. Notice that the residue unit is [deg / day].   (Default = nothing)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"It returns:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"T: Semi-major axis [m] of the Sun-synchronous orbit with inclination i and   eccentricity e.\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/#Example-3","page":"Sun Synchronous Orbits","title":"Example","text":"","category":"section"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Let's find the semi-major axis that turns an orbit with inclination axis 98.190° and eccentricity 0.001987 into a Sun-synchronous one:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"a, converged = sun_sync_orbit_semi_major_axis(98.190 |> deg2rad, 0.001987)\na / 1000","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/#Designing-Sun-Synchronous,-Ground-Repeating-Orbits","page":"Sun Synchronous Orbits","title":"Designing Sun-Synchronous, Ground-Repeating Orbits","text":"","category":"section"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The most common type of a Sun-synchronous orbit is a ground-repeating one. In this case, we have a Sun-synchronous orbit, as mentioned before, whose ground track repeats after a finite number of (solar) days. The ground-repeating condition happens if the satellite performs a rational number of orbits per solar day:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"R_d = I + fracND ","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"where R_d is the number of revolutions per day, and I N D in mathbbN. If the greatest common divisor of N and D is one, the ground track of such an orbit repeats after NI + D revolutions, or D solar days.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"If an orbit has R_d revolutions per solar day, we can compute its angular velocity as follows:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"omega_o = R_d frac2pi86400 ","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Hence, we can design a Sun-synchronous, ground-repeating orbit by numerically solving the system:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"beginaligned\n  fracdOmegadt(a_0 i_0) = 09856473598947981^circ  s  \n  barn(a_0 i_0) = R_d frac2pi86400 \nendaligned","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"using the same method we described in the Section Designing Sun-Synchronous Orbits from Angular Velocity.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The function:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"design_sun_sync_ground_repeating_orbit(minimum_repetition::Int, maximum_repetition::Int; kwargs...) -> DataFrame","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"lists all the Sun synchronous, ground repeating orbits in which their repetition period is in the interval [minimum_repetition, maximum_repetition] days.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"This function returns a DataFrame with the following columns:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"semi_major_axis: Orbit semi-major axis.\naltitude: Orbit altitude above the Equator (a - R0).\ninclination: Orbit inclination.\nperiod: Orbital period.\nrev_per_days: If the keyword pretify_rev_per_days is false, this column contains   Tuples with the integer and rational parts of the number of revolutions per day.   Otherwise, it contains a string with a prety representation of the number of revolutions   per day.\nadjacent_gt_distance: Distance between two adjacent ground tracks at Equator.\nadjacent_gt_angle: Angle between two adjacent ground tracks at Equator measured from the   satellite position.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"note: Note\nThe units of those columns depends on the keywords.","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"The following keywords are available:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"angle_unit::Symbol: Unit for all the angles in the output DataFrame.  It can be :deg   for degrees or :rad for radians.   (Default: :deg)\ndistance_unit::Symbol: The unit for all the distances in the output DataFrame. It can   be :m for meters or :km for kilometers.   (Default: :km)\neccentricity::Number: Orbit eccentricity.   (Default: 0)\nint_rev_per_day::Tuple: Tuple with the integer parts of the number of revolutions per   day to be analyzed.   (Default = (13, 14, 15, 16, 17))\npretity_rev_per_days::Bool: If true, the column with the revolutions per day will be   conveted to a string with a pretty representation of this information.   (Default: true)\nmaximum_altitude::Union{Nothing, Number}: Maximum altitude [m] of the orbits in the   output DataFrame. If it is nothing, the algorithm will not apply a higher limit to   the orbital altitude.   (Default = nothing)\nminimum_altitude::Union{Nothing, Number}: Minimum altitude [m] of the orbits in the   output DataFrame. If it is nothing, the algorithm will not apply a lower limit to   the orbital altitude.   (Default = nothing)\ntime_unit::Symbol: Unit for all the time values in the output DataFrame.  It can be   :s for seconds, :m for minutes, or :h for hours.   (Default = :h)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/#Example-4","page":"Sun Synchronous Orbits","title":"Example","text":"","category":"section"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"Let's find all the possible orbits between 650km and 800km that repeat the ground track in, at most, 5 days:","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"df = design_sun_sync_ground_repeating_orbit(\n    1,\n    5;\n    minimum_altitude = 650e3,\n    maximum_altitude = 800e3\n)\nshow(df; crop = :none)","category":"page"},{"location":"man/orbits/sun_synchronous_orbits/","page":"Sun Synchronous Orbits","title":"Sun Synchronous Orbits","text":"info: Info\nThe designer can use the fields adjacent_gt_distance and adjacent_gt_angle to check whether the mission payload can operate correctly in the orbit. For example, in orbit #4, the payload swath of a remote sensing satellite with a camera must be higher than 543.811 km. Otherwise, there will be gaps in the images.","category":"page"},{"location":"man/eclipse_time/#Eclipse-Time","page":"Eclipse Time","title":"Eclipse Time","text":"","category":"section"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"using SatelliteAnalysis","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The eclipse time is the period the satellite does not receive sunlight due to the Earth shadow. This information is paramount for mission design since it directly interferes in the power and thermal subsystems.","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"We can compute the eclipse time of a satellite using the function:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"eclipse_time_summary(orbp::OrbitPropagator; kwargs...) -> DataFrame","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"This function computes the eclipse time summary for the orbit propagator orbp. The summary is computed as the total time the object stays in the sunlight, penumbra, and umbra regions per orbit at each day. The algorithm was adapted from [1].","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The following keywords are available:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"num_days::Number: Number of days in which the analysis will be performed. (Default = 365)\nstep::Number: The step in which the propagation will occur. Notice that this function has a crossing estimation to accurately estimate the transition between the regions. However, if this step is very large, we may miss some small regions. If it is negative, it will be selected as the time in which the mean anomaly advances 0.5°. (Default = -1)\nunit::Symbol: Select the unit in which the results will be generated. The possible values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The function returns a DataFrame with three columns:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"sunlight: Total sunlight time per orbit at each day [unit].\npenumbra: Total penumbra time per orbit at each day [unit].\numbra: Total umbra time per orbit at each day [unit].","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The unit of each column is stored in the DataFrame using metadata.","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"note: Note\nIf we want to verify the current lighting condition in a satellite (sunlight, umbra, or penumbra), see the function lighting_condition.","category":"page"},{"location":"man/eclipse_time/#Examples","page":"Eclipse Time","title":"Examples","text":"","category":"section"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"We will compute the eclipse time of the Amazonia-1 mission for one year. The first thing we need to do is define the orbit:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"jd₀ = date_to_jd(2021, 1, 1)\n\norb = KeplerianElements(\n    jd₀,\n    7130.982e3,\n    0.001111,\n    98.405 |> deg2rad,\n    ltdn_to_raan(10.5, jd₀),\n    π / 2,\n    0\n)","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The next step is to define the desired propagator:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"orbp = Propagators.init(Val(:J2), orb)","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"Now, we can use the function eclipse_time_summary to obtain the eclipse time information for each day of the year:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"df = eclipse_time_summary(orbp; unit = :m)","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"Finally, we can use the DataFrame to analyze the result. For example, the maximum eclipse time in an orbit is:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"maximum(df.penumbra .+ df.umbra)","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"i.e., 34.66 minutes.","category":"page"},{"location":"man/eclipse_time/#References","page":"Eclipse Time","title":"References","text":"","category":"section"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"[1] Longo, C. R. O., Rickman, S. L (1995). Method for the Calculation of Spacecraft Umbra and Penumbra Shadow Terminator Points. NASA Technical Paper 3547.","category":"page"},{"location":"man/frozen_orbits/#Frozen-Orbits","page":"Frozen Orbits","title":"Frozen Orbits","text":"","category":"section"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"using SatelliteAnalysis","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"Due to the Earth's gravitational perturbation, the orbit of a salite will experience secular changes in the argument of perigee. Hence, the satellite mean altitude per latitude will differ during the mission. This effect can be problematic, especially if we must compare images by a camera onboard the satellite in different periods. The altitude variation will change the resolution, leading to some problems when comparing the data.","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"We can avoid this problem if we compute an eccentricity e  and the argument of perigee omega that yields theoretically:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"beginequation*\n  fracdedt = 0 fracdomegadt = 0 \nendequation*","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"This orbit is called frozen. Refer to [1] for more information.","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"We can use the function:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"frozen_orbit(a::Number, i::Number; kwargs...) -> Float64, Float64","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"to compute the eccentricity [ ] and argument of perigee [rad] that yield a frozen orbit when the orbit has semi-major axis a [m] and inclination i [rad]. This function uses the theory in [1].","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"note: Note\nThis function uses BigFloat internally to perform all computations, allowing very high degrees. However, the user must ensure that the default precision is enough for the required degree. Refer to the function setprecision for more information.","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"The following keywords are available:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"gravity_model::Union{Nothing, AbstractGravityModel}: Gravity model used to compute the   frozen eccentricity. Refer to the object AbstractGravityModel of the package   SatelliteToolboxGravityModels.jl for more information. If it is nothing, the system   will automatically fetch and load the EGM96 gravity model. However, loading a gravity   model can significantly decrease the performance. Thus, it is advisable to pass a   gravity model here.   (Default = nothing)\nmax_degree: Maximum gravity model degree used to compute the frozen eccentricity. If it   is equal to or lower than 0, the maximum degree in grav_model will be used. Otherwise,   if it is lower than 3 or higher than the grav_model maximum degree, it will be clamped   accordingly.   (Default = 53)","category":"page"},{"location":"man/frozen_orbits/#Examples","page":"Frozen Orbits","title":"Examples","text":"","category":"section"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"We will compute the eccentricity and argument of perigee that yields a frozen orbit using the data from Amazonia-1 mission. First, we will use only 5 degrees, and the default gravity model (EGM96):","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"frozen_orbit(7130.982e3, 98.410 |> deg2rad; max_degree = 5)\n\ne, ω = frozen_orbit(7130.982e3, 98.410 |> deg2rad; max_degree = 5)\n\ne\n\nω |> rad2deg","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"If we want to use all the 360 terms in EGM96, we need to increase the precision of BigFloat to keep the accuracy:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"setprecision(1024)\n\ne, ω = frozen_orbit(7130.982e3, 98.410 |> deg2rad; max_degree = 5)\n\ne\n\nω |> rad2deg","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"We can use a different gravity model as follows:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"jgm3 = GravityModels.load(IcgemFile, fetch_icgem_file(:JGM3))\n\ne, ω = frozen_orbit(7130.982e3, 98.410 |> deg2rad; max_degree = 70, gravity_model = jgm3)\n\ne\n\nω |> rad2deg","category":"page"},{"location":"man/frozen_orbits/#References","page":"Frozen Orbits","title":"References","text":"","category":"section"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"[1] Rosborough, G. W.; Ocampo, C. A (1991). Influence of higher degree zonals on the frozen orbit geometry. Proceedings of the AAS/AIAA Astrodynamics Conference, Durango, CO.","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/#Ground-Facility-Gaps","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"using SatelliteAnalysis","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"We can use the function:","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"ground_facility_gaps(orbp, args...; duration::Number = 86400, initial_time::Number = 0, kwargs...) -> DataFrame","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"to compute the gaps between the accesses of ground facilities. The arguments and keywords are the same as the ones used in the function ground_facility_accesses (see Ground Facility Accesses).","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"Notice that the gap analysis starts in the orbit propagator epoch plus initial_time and lasts for duration [s].","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"This function returns a DataFrame with three columns:","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"access_beginning: Time of the access beginning [UTC] encoded using DateTime.\naccess_end: Time of the access end [UTC] encoded using DateTime.\nduration: Duration of the access [s]. The unit of the column duration is stored in the DataFrame using metadata.","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/#Examples","page":"Ground Facility Gaps","title":"Examples","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"Let's compute the gaps of the Amazonia-1 satellite to the INPE's ground station at Cuiabá, MT, Brazil.","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"First, we need to define an orbit propagator. In this case, we will use the TLE obtained from CelesTrak when this documentation was written:","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"tle_amz1 = tle\"\"\"\n    AMAZONIA 1\n    1 47699U 21015A   24008.13079366  .00000299  00000+0  10693-3 0  9994\n    2 47699  98.4120  87.2350 0001570  92.1147 268.0222 14.40836963150331\n    \"\"\"\n\norbp = Propagators.init(Val(:SGP4), tle_amz1)","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"Now, we can compute the gaps during one day considering the INPE's station at Cuiabá:","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"ground_facility_gaps(\n    orbp,\n    [(-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)];\n    duration = 1 * 86400,\n    minimum_elevation = 5 |> deg2rad,\n    unit = :m\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"If we want to change the reference frames used in the analysis, we must provide a function f_eci_to_ecef(r_i, jd) that converts the vector r_i to the desired ECEF frame at the instant jd [Julian Day]. For example, let's use the more precise ITRF instead of the PEF (default):","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"const eop = fetch_iers_eop(Val(:IAU1980));\n\nfunction f_eci_to_ecef(r_teme, jd)\n    D_itrf_teme = r_eci_to_ecef(TEME(), ITRF(), jd, eop)\n    r_itrf = D_itrf_teme * r_teme\n    return r_itrf\nend\n\nground_facility_gaps(\n    orbp,\n    [(-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)];\n    duration = 1 * 86400,\n    f_eci_to_ecef = f_eci_to_ecef,\n    minimum_elevation = 5 |> deg2rad,\n    unit = :m\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"We can also perform analyses using multiple ground facilities. For example, let's find the accumulated gap if we consider the INPE's stations at Cuiabá, MT, Brazil, and Alcântara, MA, Brazil:","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"ground_facility_gaps(\n    orbp,\n    [\n        (-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)\n        (-( 2 + 20 / 60) |> deg2rad, -(44 + 24 / 60) |> deg2rad, 0)\n    ];\n    duration = 1 * 86400,\n    minimum_elevation = 5 |> deg2rad,\n    unit = :m\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"By default, the algorithm computes the accumulated gap, i.e., it considers the gap active if neither station has visibility to the satellite. We can change this logic by overloading the function in the keyword parameter reduction. For example, let's compute the gap when the satellite does not have visibility to both ground stations at the same time:","category":"page"},{"location":"man/ground_facilities/ground_facility_gaps/","page":"Ground Facility Gaps","title":"Ground Facility Gaps","text":"ground_facility_gaps(\n    orbp,\n    [\n        (-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)\n        (-( 2 + 20 / 60) |> deg2rad, -(44 + 24 / 60) |> deg2rad, 0)\n    ];\n    duration = 1 * 86400,\n    minimum_elevation = 5 |> deg2rad,\n    reduction = v -> (&)(v...),\n    unit = :m\n)","category":"page"},{"location":"#SatelliteAnalysis.jl","page":"Home","title":"SatelliteAnalysis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains several functions to perform analysis related to satellites. Those functions were split from the package SatelliteToolbox.jl.","category":"page"},{"location":"#Instalation","page":"Home","title":"Instalation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"SatelliteAnalysis\")","category":"page"}]
}
