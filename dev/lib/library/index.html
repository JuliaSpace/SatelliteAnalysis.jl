<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Satellite Analysis</title><meta name="title" content="Library · Satellite Analysis"/><meta property="og:title" content="Library · Satellite Analysis"/><meta property="twitter:title" content="Library · Satellite Analysis"/><meta name="description" content="Documentation for Satellite Analysis."/><meta property="og:description" content="Documentation for Satellite Analysis."/><meta property="twitter:description" content="Documentation for Satellite Analysis."/><meta property="og:url" content="https://juliaspace.github.io/SatelliteAnalysis.jl/stable/lib/library/"/><meta property="twitter:url" content="https://juliaspace.github.io/SatelliteAnalysis.jl/stable/lib/library/"/><link rel="canonical" href="https://juliaspace.github.io/SatelliteAnalysis.jl/stable/lib/library/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Satellite Analysis logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Satellite Analysis</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../man/beta_angle/">Beta Angle</a></li><li><a class="tocitem" href="../../man/eclipse_time/">Eclipse Time</a></li><li><a class="tocitem" href="../../man/frozen_orbits/">Frozen Orbits</a></li><li><span class="tocitem">Ground Facilities</span><ul><li><a class="tocitem" href="../../man/ground_facilities/ground_facility_accesses/">Ground Facility Accesses</a></li><li><a class="tocitem" href="../../man/ground_facilities/ground_facility_gaps/">Ground Facility Gaps</a></li><li><a class="tocitem" href="../../man/ground_facilities/ground_facility_visibility_circle/">Ground Facility Visibility Circle</a></li></ul></li><li><a class="tocitem" href="../../man/ground_track/">Ground Track</a></li><li><span class="tocitem">Orbits</span><ul><li><a class="tocitem" href="../../man/orbits/sun_synchronous_orbits/">Sun Synchronous Orbits</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/main/docs/src/lib/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documentation for <code>SatelliteAnalysis.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis._F_and_∂F_l0p-Tuple{Integer, Integer, Number}" href="#SatelliteAnalysis._F_and_∂F_l0p-Tuple{Integer, Integer, Number}"><code>SatelliteAnalysis._F_and_∂F_l0p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_F_and_∂F_l0p(l::Integer, p::Integer, i::Number) -&gt; BigFloat, BigFloat</code></pre><p>Compute the inclination function <code>F_{l,0,p}(i)</code> and its derivative <code>∂F_{l,0,p} / ∂i</code>as defined in <strong>[1, p. 642]</strong>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Internally, we must use <code>BigFloat</code> to allow calculations on high degrees.</p></div></div><p><strong>References</strong></p><ul><li><strong>[1]</strong> Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications. 4th ed.   Microcosm Press, Hawthorne, CA.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/frozen_orbits.jl#L179-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.beta_angle-Tuple{KeplerianElements, Number}" href="#SatelliteAnalysis.beta_angle-Tuple{KeplerianElements, Number}"><code>SatelliteAnalysis.beta_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">beta_angle(orb::KerplerianElements{Tepoch, T}, Δjd::Number; kwargs...) -&gt; Float64</code></pre><p>Compute the beta angle [rad] for the orbit <code>orb</code> after <code>Δjd</code> days from its epoch.</p><p>The algorithm was obtained from <strong>[1]</strong>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is expected that the input elements are represented in the TOD reference frame. If it is not the case, they can be converted using the function <code>orb_eci_to_eci</code> of <strong>SatelliteToolboxTransformations.jl</strong>.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>perturbation::Symbol</code>: Select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:<ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J₂.</li><li><code>:J4</code>: Consider the perturbation terms J₂, J₂², and J₄.</li></ul>(<strong>Default</strong>: <code>:J2</code>)</li></ul><p><strong>References</strong></p><ul><li><strong>[1]</strong>: Mortari, D., Wilkins, M. P., and Bruccoleri, C.  On Sun-Synchronous Orbits and   Associated Constellations</li></ul><p><strong>Extended Help</strong></p><p>The beta angle is the angle between the orbit plane and the Sun. The positive direction is defined as that of the orbit angular momentum.</p><p>The beta angle is useful when computing the mean amount of solar radiation a satellite receives in a particular orbit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis, UnicodePlots

julia&gt; jd₀ = date_to_jd(2021, 1, 1, 0, 0, 0)

julia&gt; orb = KeplerianElements(
            jd₀,
            7130.982e3,
            0.001111,
            98.405 |&gt; deg2rad,
            ltdn_to_raan(10.5, jd₀),
            90     |&gt; deg2rad,
            0
        )

julia&gt; β = beta_angle.(orb, 0:1:364)

julia&gt; lineplot(0:1:364, rad2deg.(β), xlabel = &quot;Day&quot;, ylabel = &quot;Beta angle [°]&quot;)
                     ┌────────────────────────────────────────┐
                  30 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     │⠀⣠⠞⠉⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     │⡴⠁⠀⠀⠀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠃⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠁⠀⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⠀⠀⠀⠀⠀⠀⣠⠞⠀⠀⠀⠀⠀⠀│
   Beta angle [°]    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠋⠀⠀⠀⠉⠓⠲⠤⠴⠚⠁⠀⠀⠀⠀⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣄⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠦⣄⣀⡠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                  10 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
                     └────────────────────────────────────────┘
                     ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀400⠀
                     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Day⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/beta_angle.jl#L14-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.design_sun_sync_ground_repeating_orbit-Tuple{Int64, Int64}" href="#SatelliteAnalysis.design_sun_sync_ground_repeating_orbit-Tuple{Int64, Int64}"><code>SatelliteAnalysis.design_sun_sync_ground_repeating_orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">design_sun_sync_ground_repeating_orbit(minimum_repetition::Int, maximum_repetition::Int; kwargs...) -&gt; DataFrame</code></pre><p>List all the Sun synchronous, ground repeating orbits in which their repetition period is in the interval <code>[minimum_repetition, maximum_repetition]</code> days.</p><p>This function returns a <code>DataFrame</code> with the following columns:</p><ul><li><code>semi_major_axis</code>: Orbit semi-major axis.</li><li><code>altitude</code>: Orbit altitude above the Equator <code>(a - R0)</code>.</li><li><code>inclination</code>: Orbit inclination.</li><li><code>period</code>: Orbital period.</li><li><code>rev_per_days</code>: If the keyword <code>pretify_rev_per_days</code> is <code>false</code>, this column contains   <code>Tuple</code>s with the integer and rational parts of the number of revolutions per day.   Otherwise, it contains a string with a prety representation of the number of revolutions   per day.</li><li><code>adjacent_gt_distance</code>: Distance between two adjacent ground tracks at Equator.</li><li><code>adjacent_gt_angle</code>: Angle between two adjacent ground tracks at Equator measured from the   satellite position.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The units of those columns depends on the keywords.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>angle_unit::Symbol</code>: Unit for all the angles in the output <code>DataFrame</code>.  It can be <code>:deg</code>   for degrees or <code>:rad</code> for radians.   (<strong>Default</strong>: <code>:deg</code>)</li><li><code>distance_unit::Symbol</code>: The unit for all the distances in the output <code>DataFrame</code>. It can   be <code>:m</code> for meters or <code>:km</code> for kilometers.   (<strong>Default</strong>: <code>:km</code>)</li><li><code>eccentricity::Number</code>: Orbit eccentricity.   (<strong>Default</strong>: 0)</li><li><code>int_rev_per_day::Tuple</code>: <code>Tuple</code> with the integer parts of the number of revolutions per   day to be analyzed.   (<strong>Default</strong> = <code>(13, 14, 15, 16, 17)</code>)</li><li><code>pretity_rev_per_days::Bool</code>: If <code>true</code>, the column with the revolutions per day will be   conveted to a string with a pretty representation of this information.   (<strong>Default</strong>: <code>true</code>)</li><li><code>maximum_altitude::Union{Nothing, Number}</code>: Maximum altitude [m] of the orbits in the   output <code>DataFrame</code>. If it is <code>nothing</code>, the algorithm will not apply a higher limit to   the orbital altitude.   (<strong>Default</strong> = <code>nothing</code>)</li><li><code>minimum_altitude::Union{Nothing, Number}</code>: Minimum altitude [m] of the orbits in the   output <code>DataFrame</code>. If it is <code>nothing</code>, the algorithm will not apply a lower limit to   the orbital altitude.   (<strong>Default</strong> = <code>nothing</code>)</li><li><code>time_unit::Symbol</code>: Unit for all the time values in the output <code>DataFrame</code>.  It can be   <code>:s</code> for seconds, <code>:m</code> for minutes, or <code>:h</code> for hours.   (<strong>Default</strong> = <code>:h</code>)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong> = <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong> = <code>EGM_2008_J2</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong> = <code>EARTH_EQUATORIAL_RADIUS</code>)</li><li><code>we::Number</code>: Earth&#39;s angular speed [rad / s].   (<strong>Default</strong>: <code>EARTH_ANGULAR_SPEED</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/sun_synchronous_orbits.jl#L17-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.eclipse_time_summary-Tuple{OrbitPropagator}" href="#SatelliteAnalysis.eclipse_time_summary-Tuple{OrbitPropagator}"><code>SatelliteAnalysis.eclipse_time_summary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eclipse_time_summary(orbp::OrbitPropagator; kwargs...) -&gt; DataFrame</code></pre><p>Compute the eclipse time summary for the orbit propagator <code>orbp</code>. The summary is computed as the total time the object stays in the sunlight, penumbra, and umbra regions per orbit at each day.</p><p><strong>Keywords</strong></p><ul><li><code>num_days::Number</code>: Number of days in which the analysis will be performed.   (<strong>Default</strong> = 365)</li><li><code>step::Number</code>: The step in which the propagation will occur. Notice that this function   has a crossing estimation to accurately estimate the transition between the regions.   However, if this step is very large, we may miss some small regions. If it is negative,   it will be selected as the time in which the mean anomaly advances 0.5°.   (<strong>Default</strong> = -1)</li><li><code>unit::Symbol</code>: Select the unit in which the results will be generated. The possible   values are:<ul><li><code>:s</code> for seconds (<strong>Default</strong>);</li><li><code>:m</code> for minutes; or</li><li><code>:h</code> for hours.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: The function returns a <code>DataFrame</code> with three columns:<ul><li><code>sunlight</code>: Total sunlight time per orbit at each day [<code>unit</code>].</li><li><code>penumbra</code>: Total penumbra time per orbit at each day [<code>unit</code>].</li><li><code>umbra</code>: Total umbra time per orbit at each day [<code>unit</code>].</li></ul>The unit of each column is stored in the <code>DataFrame</code> using metadata.</li></ul><p><strong>Extended Help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis

julia&gt; orb = KeplerianElements(
           date_to_jd(2021, 1, 1, 0, 0, 0),
           7130.982e3,
           0.001111,
           98.405 |&gt; deg2rad,
           ltdn_to_raan(10.5, jd₀),
           90     |&gt; deg2rad,
           0
       )

julia&gt; orbp = Propagators.init(Val(:J2), orb)

julia&gt; df = eclipse_time_summary(orbp; num_days = 5)
5×4 DataFrame
 Row │ date        sunlight  penumbra  umbra
     │ Date        Float64   Float64   Float64
─────┼─────────────────────────────────────────
   1 │ 2021-01-01   3972.63   20.4117  2006.96
   2 │ 2021-01-02   3973.85   20.4376  2005.71
   3 │ 2021-01-03   3974.77   20.4575  2004.77
   4 │ 2021-01-04   3975.74   20.4758  2003.79
   5 │ 2021-01-05   3976.94   20.5022  2002.55

julia&gt; df = eclipse_time_summary(orbp; num_days = 5, unit = :m)
5×4 DataFrame
 Row │ date        sunlight  penumbra  umbra
     │ Date        Float64   Float64   Float64
─────┼─────────────────────────────────────────
   1 │ 2021-01-01   66.2105  0.340195  33.4493
   2 │ 2021-01-02   66.2308  0.340627  33.4285
   3 │ 2021-01-03   66.2461  0.340958  33.4129
   4 │ 2021-01-04   66.2623  0.341263  33.3964
   5 │ 2021-01-05   66.2824  0.341704  33.3759

julia&gt; colmetadata(df)
Dict{Symbol, Dict{String, Symbol}} with 3 entries:
  :penumbra =&gt; Dict(&quot;Unit&quot;=&gt;:m)
  :sunlight =&gt; Dict(&quot;Unit&quot;=&gt;:m)
  :umbra    =&gt; Dict(&quot;Unit&quot;=&gt;:m)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/eclipse_time.jl#L14-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.fetch_country_polygons" href="#SatelliteAnalysis.fetch_country_polygons"><code>SatelliteAnalysis.fetch_country_polygons</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fetch_country_polygons(url = &quot;https://pkgstore.datahub.io/core/geo-countries/countries/archive/23f420f929e0e09c39d916b8aaa166fb/countries.geojson&quot;; kwargs...) -&gt; String</code></pre><p>Fetch the GeoJSON file with the country polygons in <code>url</code>. The algorithm stores the file in a scratch space. The function returns a <code>String</code> with the file path.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the file has already been downloaded, this function only returns its path. However, if the keyword <code>force_download</code> is <code>true</code>, the file is downloaded again from <code>url</code>.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>force_download::Bool</code>: Download the file from <code>url</code> even if it already exists.   (<strong>Default</strong> = <code>false</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/plotting/fetch_country_polygons.jl#L9-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.find_crossing-Union{Tuple{N}, Tuple{Function, Number, Number, Any, Any, Vararg{Any, N}}} where N" href="#SatelliteAnalysis.find_crossing-Union{Tuple{N}, Tuple{Function, Number, Number, Any, Any, Vararg{Any, N}}} where N"><code>SatelliteAnalysis.find_crossing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_crossing(f::Function, t₀::Number, t₁::Number, s₀, s₁, vargs...; Δ = 1e-3, max = 100, kwargs...) -&gt; T</code></pre><p>Return the crossing time <code>tc</code> in which the function <code>f(t)</code> goes from the state <code>s₀</code> to the state <code>s₁</code>. It is assumed that <code>f(t₀) = s₀</code> and <code>f(t₁) = s₁</code>.</p><p>The parameters in <code>vargs...</code> are passed to the function <code>f</code> after <code>t</code>, and the keywords <code>kwargs...</code> are also passed to <code>f</code>. Hence, it will always be called as <code>f(t, vargs...; kwargs...)</code>.</p><p>If the computed interval is smaller than <code>Δ</code>, or if the number of iterations is higher than <code>max</code>, the algorithm stops.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The output type <code>T</code> is obtained by the type of <code>(t₁ + t₂) / 2</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SatelliteAnalysis.find_crossing(
    t -&gt; (sin(t) &gt; 0),
    -0.3,
    0.3,
    false,
    true;
    Δ = 1e-10
)
6.984919309616089e-11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/misc/find_crossing.jl#L7-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.frozen_orbit-Tuple{Number, Number}" href="#SatelliteAnalysis.frozen_orbit-Tuple{Number, Number}"><code>SatelliteAnalysis.frozen_orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frozen_orbit(a::Number, i::Number; kwargs...) -&gt; Float64, Float64</code></pre><p>Compute the eccentricity [ ] and argument of perigee [rad] to obtain a frozen orbit when the orbit has semi-major axis <code>a</code> [m] and inclination <code>i</code> [rad]. This function uses the theory in <strong>[1]</strong>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function uses <code>BigFloat</code> internally to perform all computations, allowing very high degrees. However, the user must ensure that the default precision is enough for the required degree. Refer to the function <code>setprecision</code> for more information.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>gravity_model::Union{Nothing, AbstractGravityModel}</code>: Gravity model used to compute the   frozen eccentricity. Refer to the object <code>AbstractGravityModel</code> of the package   <code>SatelliteToolboxGravityModels.jl</code> for more information. If it is <code>nothing</code>, the system   will automatically fetch and load the EGM96 gravity model. However, loading a gravity   model can significantly decrease the performance. Thus, it is advisable to pass a   gravity model here.   (<strong>Default</strong> = <code>nothing</code>)</li><li><code>max_degree</code>: Maximum gravity model degree used to compute the frozen eccentricity. If it   is equal to or lower than 0, the maximum degree in <code>grav_model</code> will be used. Otherwise,   if it is lower than 3 or higher than the <code>grav_model</code> maximum degree, it will be clamped   accordingly.   (<strong>Default</strong> = 53)</li></ul><p><strong>References</strong></p><ul><li><strong>[1]</strong> Rosborough, G. W.; Ocampo, C. A (1991). Influence of higher degree zonals on the   frozen orbit geometry. Proceedings of the AAS/AIAA Astrodynamics Conference, Durango,   CO.</li></ul><p><strong>Extended Help</strong></p><p>Due to the Earth&#39;s gravitational perturbation, the orbit of a salite will experience secular changes in the argument of perigee. Hence, the satellite mean altitude per latitude will differ during the mission. This effect can be problematic, especially if we must compare images by a camera onboard the satellite in different periods. The altitude variation will change the resolution, leading to some problems when comparing the data.</p><p>We can avoid this problem if we compute an eccentricity and the argument of perigee that yields theoretically:</p><pre><code class="nohighlight hljs">de      dω
── = 0, ── = 0
dt      dt</code></pre><p>This orbit is called <strong>frozen</strong>. Refer to <strong>[1]</strong> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis

julia&gt; frozen_orbit(7130.982e3, 98.410 |&gt; deg2rad)
(0.0011641853028456078, 1.5707963267948966)

julia&gt; jgm3 = GravityModels.load(IcgemFile, fetch_icgem_file(:JGM3))
[ Info: Downloading the ICGEM file &#39;JGM3.gfc&#39; from &#39;http://icgem.gfz-potsdam.de/getmodel/gfc/a3375e01a717ac162962138a5e94f10
466b71aa4a130d7f7d5b18ab3d5f90c3d/JGM3.gfc&#39;...
IcgemFile{Float64}:
      Product type : gravity_field
       Model name  : JGM3
  Gravity constant : 3.986004415e14
            Radius : 6.3781363e6
    Maximum degree : 70
            Errors : formal
       Tide system : unknown
              Norm : fully_normalized
         Data type : Float64

julia&gt; frozen_orbit(7130.982e3, 98.410 |&gt; deg2rad; gravity_model = jgm3)
(0.001163484769069545, 1.5707963267948966)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/frozen_orbits.jl#L21-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.ground_facility_accesses-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}" href="#SatelliteAnalysis.ground_facility_accesses-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>SatelliteAnalysis.ground_facility_accesses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ground_facility_accesses(orbp, [(WGS84)]; kwargs...) -&gt; DataFrame</code></pre><p>Compute the accesses of a satellite with orbit propagator <code>orbp</code> (see <code>Propagators.init</code>) to the ground facilities defined in the vector <code>[(WGS84)]</code>. The analysis interval begins in the propagator epoch plus <code>initial_time</code> and lasts for <code>duration</code> [s], where both are keywords.</p><p>The ground facilities are specified using a vector of tuples with three numbers:</p><pre><code class="nohighlight hljs">Tuple{T1, T2, T3} where {T1 &lt;: Number, T2 &lt;: Number, T3 &lt;: Number}</code></pre><p>containing the WGS84 position of each ground facility <code>[(WGS84)]</code>:</p><pre><code class="nohighlight hljs">(latitude [rad], longitude [rad], altitude [m])</code></pre><p>Those geodetic information are transformed to an ECEF vector using the function <code>geodetic_to_ecef</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function computes the accesses using multiple threads. Hence, the function <code>f_eci_to_ecef</code> must be thread safe.</p></div></div><p><strong>Keywords</strong></p><ul><li><p><code>duration::Number</code>: Duration of the analysis [s].   (<strong>Default</strong> = 86400)</p></li><li><p><code>f_eci_to_ecef::Function</code>: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be</p><p><code>f_eci_to_ecef(r_i::AbstractVector, jd::Number) -&gt; AbstractVector</code></p><p>and it must return the position vector <code>r_i</code> represented in the ECEF at the instant <code>jd</code>   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (<strong>Default</strong>: <code>_ground_facility_default_eci_to_ecef</code>)</p></li><li><p><code>initial_time::Number</code>: Initial time of the analysis after the propagator epoch [s].   (<strong>Default</strong> = 0)</p></li><li><p><code>minimum_elevation::Number</code>: Minimum elevation angle for communication between the   satellite and the ground facilities [rad].   (<strong>Default</strong> = 10°)</p></li><li><p><code>num_chunks::Number</code>: Number of chunks the algorithm will divide the time vector to   compute the accesses.   (<strong>Default</strong> = <code>Threads.nthreads()</code>)</p></li><li><p><code>reduction::Function</code>: A function that receives a boolean vector with the visibility   between the satellite and each ground facility. It must return a boolean value   indicating if the access must be computed or not. This is useful to merge access time   between two or more facilities.   (<strong>Default</strong> = <code>v -&gt; |(v...)</code> <em>i.e.</em> compute the access if at least one ground   facilities is visible)</p></li><li><p><code>step::Number</code>: The step [s] used to propagate the orbit. Notice that we perform a cross   tuning to accurately obtain the access time. However, if an access is lower than the   step, it can be neglected.   (<strong>Default</strong> = 60)</p></li><li><p><code>unit::Symbol</code>: Select the unit in which the duration will be computed. The possible   values are:</p><ul><li><code>:s</code> for seconds (<strong>Default</strong>);</li><li><code>:m</code> for minutes; or</li><li><code>:h</code> for hours.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: The function returns a <code>DataFrame</code> with three columns:<ul><li><code>access_beginning</code>: Time of the access beginning [UTC] encoded using <code>DateTime</code>.</li><li><code>access_end</code>: Time of the access end [UTC] encoded using <code>DateTime</code>.</li><li><code>duration</code>: Duration of the access [s].</li></ul>The unit of the column <code>duration</code> is stored in the <code>DataFrame</code> using metadata.</li></ul><p><strong>Extended Help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis

julia&gt; jd₀ = date_to_jd(2024, 1, 1);

julia&gt; orb = KeplerianElements(
           jd₀,
           7130.982e3,
           0.001111,
           98.405 |&gt; deg2rad,
           ltdn_to_raan(10.5, jd₀),
           π / 2,
           0
       );

julia&gt; orbp = Propagators.init(Val(:J2), orb);

julia&gt; ground_facility_accesses(orbp, (0, 0, 0))
2×3 DataFrame
 Row │ access_beginning         access_end               duration 
     │ DateTime                 DateTime                 Float64  
─────┼────────────────────────────────────────────────────────────
   1 │ 2024-01-01T10:20:03.136  2024-01-01T10:30:02.971   599.835
   2 │ 2024-01-01T22:49:55.910  2024-01-01T22:59:23.470   567.56

julia&gt; ground_facility_accesses(orbp, (0, 0, 0); unit = :m)
2×3 DataFrame
 Row │ access_beginning         access_end               duration 
     │ DateTime                 DateTime                 Float64  
─────┼────────────────────────────────────────────────────────────
   1 │ 2024-01-01T10:20:03.136  2024-01-01T10:30:02.971   9.99725
   2 │ 2024-01-01T22:49:55.910  2024-01-01T22:59:23.470   9.45933</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/ground_facilities/ground_facility_accesses_and_gaps.jl#L9-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.ground_facility_gaps-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}" href="#SatelliteAnalysis.ground_facility_gaps-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>SatelliteAnalysis.ground_facility_gaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ground_facility_gaps(orbp, args...; duration::Number = 86400, initial_time::Number = 0, kwargs...) -&gt; DataFrame</code></pre><p>Compute the gaps between the accesses of ground facilities. The arguments and keywords are the same as the ones used in the function <a href="#SatelliteAnalysis.ground_facility_accesses-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>ground_facility_accesses</code></a>.</p><p>Notice that the gap analysis starts in the orbit propagator epoch plus <code>initial_time</code> and lasts for <code>duration</code> [s].</p><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: The function returns a <code>DataFrame</code> with three columns:<ul><li><code>gap_beginning</code>: Time of the access beginning [UTC] encoded using <code>DateTime</code>.</li><li><code>gap_end</code>: Time of the access end [UTC] encoded using <code>DateTime</code>.</li><li><code>duration</code>: Duration of the access [s].</li></ul>The unit of the column <code>duration</code> is stored in the <code>DataFrame</code> using metadata.</li></ul><p><strong>Extended Help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis

julia&gt; jd₀ = date_to_jd(2024, 1, 1);

julia&gt; orb = KeplerianElements(
           jd₀,
           7130.982e3,
           0.001111,
           98.405 |&gt; deg2rad,
           ltdn_to_raan(10.5, jd₀),
           π / 2,
           0
       );

julia&gt; orbp = Propagators.init(Val(:J2), orb);

julia&gt; ground_facility_gaps(orbp, (0, 0, 0))
3×3 DataFrame
 Row │ gap_beginning            gap_end                  duration 
     │ DateTime                 DateTime                 Float64  
─────┼────────────────────────────────────────────────────────────
   1 │ 2024-01-01T00:00:00      2024-01-01T10:20:03.136  37203.1
   2 │ 2024-01-01T10:30:02.971  2024-01-01T22:49:55.910  44392.9
   3 │ 2024-01-01T22:59:23.470  2024-01-02T00:00:00       3636.53

julia&gt; ground_facility_gaps(orbp, (0, 0, 0); unit = :m)
3×3 DataFrame
 Row │ gap_beginning            gap_end                  duration 
     │ DateTime                 DateTime                 Float64  
─────┼────────────────────────────────────────────────────────────
   1 │ 2024-01-01T00:00:00      2024-01-01T10:20:03.136  620.052
   2 │ 2024-01-01T10:30:02.971  2024-01-01T22:49:55.910  739.882
   3 │ 2024-01-01T22:59:23.470  2024-01-02T00:00:00       60.6088</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/ground_facilities/ground_facility_accesses_and_gaps.jl#L259-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.ground_facility_visibility_circle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Tuple{T1, T2, T3}, Number}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}" href="#SatelliteAnalysis.ground_facility_visibility_circle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Tuple{T1, T2, T3}, Number}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>SatelliteAnalysis.ground_facility_visibility_circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ground_facility_visibility_circle(gf_wgs84::Tuple, satellite_position_norm::Number; kwargs...) -&gt; Vector{NTuple{2, Float64}}</code></pre><p>Compute the ground facility visibility circle from the position <code>gf_wgs84</code> (WGS84) to a satellite in which its distance from the Earth&#39;s center is <code>satellite_position_norm</code> [m]. It returns a vector of <code>NTuple{2, Float64}</code> where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the visibility circle.</p><p>The ground facility is specified using a tuple with its WGS84 position:</p><pre><code class="nohighlight hljs">(latitude [rad], longitude [rad], altitude [m])</code></pre><p><strong>Keywords</strong></p><ul><li><code>azimuth_step::Number</code>: The step in the azimuth used to compute the visibility circle.   (<strong>Default</strong>: 0.1 |&gt; deg2rad)</li><li><code>minimum_elevation::Number</code>: Minimum elevation angle for communication between the   satellite and the ground facility [rad].   (<strong>Default</strong>: 10 |&gt; deg2rad)</li></ul><p><strong>Extended Help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis, UnicodePlots

julia&gt; gfv = ground_facility_visibility_circle((0, 0, 0), EARTH_EQUATORIAL_RADIUS + 700e3);

julia&gt; lineplot(last.(gfv) .|&gt; rad2deg, first.(gfv) .|&gt; rad2deg; xlim = (-180, 180), ylim = (-90, 90))
       ┌────────────────────────────────────────┐ 
    90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡼⠉⡏⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⡧⠤⡧⢼⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⣀⣇⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
   -90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       └────────────────────────────────────────┘ 
       ⠀-180⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀180⠀ 

julia&gt; gfv = ground_facility_visibility_circle((-40 |&gt; deg2rad, -60 |&gt; deg2rad, 700), EARTH_EQUATORIAL_RADIUS + 700e3);

julia&gt; lineplot(last.(gfv) .|&gt; rad2deg, first.(gfv) .|&gt; rad2deg; xlim = (-180, 180), ylim = (-90, 90))
       ┌────────────────────────────────────────┐ 
    90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠒⢦⡀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⢹⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣄⠀⠀⠀⣸⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠒⠋⠁⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
   -90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
       └────────────────────────────────────────┘ 
       ⠀-180⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀180⠀ </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/ground_facilities/ground_facility_visibility_circle.jl#L9-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.ground_repeating_orbit_adjacent_track_angle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}" href="#SatelliteAnalysis.ground_repeating_orbit_adjacent_track_angle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>SatelliteAnalysis.ground_repeating_orbit_adjacent_track_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ground_repeating_orbit_adjacent_track_angle(a::T1, e::T2, i::T3, orbit_cycle::Integer; kwargs...) where {T1 &lt;: Number, T2 &lt;: Number, T3 &lt;: Number}</code></pre><p>Compute the adjacent track angle [rad] at Equator in a ground repeating orbit measured from the satellite position. The orbit is described by its semi-major axis <code>a</code> [m], eccentricity [ ], inclination <code>i</code> [rad], and orbit cycle <code>orbit_cyle</code> [day].</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The code does not check if the orbit is ground-repeating with <code>orbit_cycle</code> [day].</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Internally, this function uses the precision obtained by promoting <code>T1</code>, <code>T2</code>, and <code>T3</code> to a float-pointing number <code>T</code>.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>perturbation::Symbol</code>: Symbol to select the perturbation terms that will be used. It can   be <code>:J0</code>, <code>:J2</code>, or <code>:J4</code>.   (<strong>Default</strong>: <code>:J2</code>)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong>: <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong>: <code>EGM_2008_J2</code>)</li><li><code>J4::Number</code>: J₄ perturbation term.   (<strong>Default</strong>: <code>EGM_2008_J4</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong>: <code>EARTH_EQUATORIAL_RADIUS</code>)</li><li><code>we::Number</code>: Earth&#39;s angular speed [rad / s].   (<strong>Default</strong>: <code>EARTH_ANGULAR_SPEED</code>)</li></ul><p><strong>Extended help</strong></p><p>A ground repeating orbit is any orbit that the number of revolutions per day is a rational number. Hence, this type of orbit repeats its ground trace after a finite number of days.</p><p>The information <code>orbit_cyle</code> is redundant given that we have <code>a</code>, <code>e</code>, and <code>i</code>. However, it is necessary to improve the algorithm precision. Otherwise, the <code>orbit_cycle</code> must be obtained by computing the orbit period using <code>a</code>, <code>e</code>, and <code>i</code> and then converting it to a rational number, leading to numerical problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/ground_repeating_orbits.jl#L15-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.ground_repeating_orbit_adjacent_track_distance-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}" href="#SatelliteAnalysis.ground_repeating_orbit_adjacent_track_distance-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>SatelliteAnalysis.ground_repeating_orbit_adjacent_track_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ground_repeating_orbit_adjacent_track_distance(orbit_period::T1, i::T2, orbit_cycle::Integer; kwargs...) where {T1 &lt;: Number, T2 &lt;: Number} -&gt; T</code></pre><p>Compute the adjacent track distance [m] at Equator in a ground repeating orbit.  The orbit is described by its orbital period <code>orbit_period</code> [s], inclination <code>i</code> [rad], and orbit cycle <code>orbit_cycle</code> [day].</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Internally, this function uses the precision obtained by promoting <code>T1</code> and <code>T2</code> to a float-pointing number <code>T</code>.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>perturbation::Symbol</code>: Symbol to select the perturbation terms that will be used. It can   be <code>:J0</code>, <code>:J2</code>, or <code>:J4</code>.   (<strong>Default</strong>: <code>:J2</code>)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong>: <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong>: <code>EGM_2008_J2</code>)</li><li><code>J4::Number</code>: J₄ perturbation term.   (<strong>Default</strong>: <code>EGM_2008_J4</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong>: <code>EARTH_EQUATORIAL_RADIUS</code>)</li><li><code>we::Number</code>: Earth&#39;s angular speed [rad / s].   (<strong>Default</strong>: <code>EARTH_ANGULAR_SPEED</code>)</li></ul><p><strong>Extended help</strong></p><p>A ground repeating orbit is any orbit that the number of revolutions per day is a rational number. Hence, this type of orbit repeats its ground trace after a finite number of days.</p><p>The information <code>orbit_period</code> and <code>orbit_cyle</code> is redundant. However, they are necessary to improve the algorithm precision. Otherwise, the <code>orbit_cycle</code> must be obtained by converting the floating-point number <code>orbit_period</code> to a rational number, leading to numerical problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/ground_repeating_orbits.jl#L134-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.ground_track-Tuple{OrbitPropagator}" href="#SatelliteAnalysis.ground_track-Tuple{OrbitPropagator}"><code>SatelliteAnalysis.ground_track</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ground_track(orbp::OrbitPropagator; kwargs...) -&gt; Vector{NTuple{2, Float64}}</code></pre><p>Compute the satellite ground track using the orbit propagator <code>orbp</code>. It returns a vector of <code>NTuple{2, Float64}</code> where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the ground track.</p><p><strong>Keywords</strong></p><ul><li><p><code>add_nans::Bool</code>: If <code>true</code>, we add <code>NaN</code> if there is a discontinuity in the ground track   to improve plotting.   (<strong>Default</strong>: true)</p></li><li><p><code>duration::Number</code>: Duration of the analysis.   (<strong>Default</strong>: 86400)</p></li><li><p><code>initial_time::Number</code>: Initial time regarding the orbit propagator <code>orbp</code> epoch [s].   (<strong>Default</strong>: 0)</p></li><li><p><code>f_eci_to_ecef::Function</code>: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be</p><p><code>f_eci_to_ecef(r_i::AbstractVector, jd::Number) -&gt; AbstractVector</code></p><p>and it must return the position vector <code>r_i</code> represented in the ECEF at the instant <code>jd</code>   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (<strong>Default</strong>: <code>_ground_track_default_eci_to_ecef</code>)</p></li><li><p><code>step::Union{Nothing, Number}</code>: Step for the computation. If <code>nothing</code>, we will roughly   compute the step to approximate 1° in the mean anomaly.   (<strong>Default</strong>: <code>nothing</code>)</p></li><li><p><code>track_types::Symbol</code>: A symbol describing what kind of track types we must add to the   output vector. It can be <code>:ascending</code> for only ascending passages, <code>:descending</code> for   only descending passages, or <code>:all</code> for both.   (<strong>Default</strong>: <code>:all</code>)</p></li></ul><p><strong>Extended Help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis, UnicodePlots

julia&gt; jd₀ = date_to_jd(2024, 1, 1);

julia&gt; orb = KeplerianElements(
           jd₀,
           7130.982e3,
           0.001111,
           98.405 |&gt; deg2rad,
           ltdn_to_raan(10.5, jd₀),
           π / 2,
           0
       );

julia&gt; orbp = Propagators.init(Val(:J2), orb);

julia&gt; gt = ground_track(orbp);

julia&gt; lineplot(last.(gt), first.(gt))
      ┌────────────────────────────────────────┐
    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⣸⡿⠿⣻⠿⣿⠿⣟⡯⢟⡿⢿⣿⡿⣿⡟⣿⡿⢿⣿⢿⣿⢻⣿⠿⣿⡟⣿⡿⣿⡿⢿⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠞⠹⡼⠙⣶⠋⢶⠋⢣⠏⢳⡞⠀⣿⡁⡽⡇⣹⡇⢨⢏⢈⢯⠀⣿⡀⡽⡁⣹⡇⢸⣯⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢦⢰⢳⢠⢿⡀⡟⡄⡞⡇⡸⣇⢸⠁⢷⠃⣷⡇⢸⡏⠸⡼⠈⣾⠀⣷⠃⢣⠇⢹⣏⠏⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢸⡞⠘⣾⠀⣿⠁⢧⠃⢹⡇⢸⡏⠀⣼⠀⣿⡆⢰⡇⢀⣇⠀⣷⠀⣾⠀⣸⡀⢸⣿⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢀⡇⠀⣇⠀⣿⠀⢸⠀⢸⡁⢨⡇⠀⡇⡇⡏⡇⣸⢳⢸⢸⢰⢻⣀⡏⡆⡇⡇⡜⣯⠀⠀⠀⠀⠀│
      │⠤⠤⠤⠤⢼⢧⢤⢿⠤⣿⠤⡿⡦⡼⡧⢼⣧⢴⠥⢧⡧⢼⡧⢼⡾⠼⣼⠤⣿⠤⣧⠧⢷⣧⢿⠤⠤⠤⠤⠤│
      │⠀⠀⠀⠀⡼⢸⢸⠸⣼⠁⣇⠇⡇⡇⢳⡞⢸⢸⠀⢸⡇⢸⡇⠈⡇⠀⡏⠀⣿⠀⢸⠀⢸⢹⠘⡆⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠁⠈⡏⠀⡿⠀⢿⠀⢹⠃⢸⡇⠘⡇⠀⡜⡇⣸⡇⢸⢧⢠⢿⠀⣿⠀⡾⡄⡸⡟⠀⣷⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢆⢰⢳⢀⢿⠀⡿⡄⡼⡆⣸⣇⢰⢧⢠⠇⣧⡇⢹⡞⠸⡼⠘⣾⠁⣷⠃⢧⢧⢷⢀⡟⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢘⣎⢈⣞⠀⣿⡁⣳⡃⣹⡇⢸⣏⢘⣞⢀⡿⢆⡼⢧⣰⢳⣠⠿⣀⠾⣄⡞⣆⢈⣿⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢹⣾⣿⣾⣿⣶⣿⣧⣿⣷⣿⣷⣾⣿⣼⣿⣷⣾⣷⣾⣵⣲⣽⣶⣿⣶⣯⣶⣼⣿⣾⣿⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
      └────────────────────────────────────────┘
      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀

julia&gt; gt = ground_track(orbp, track_types = :ascending);

julia&gt; lineplot(last.(gt), first.(gt))
      ┌────────────────────────────────────────┐
    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢸⡛⠽⡛⠿⣟⠫⣟⠫⢍⠛⠻⢿⡻⢽⡛⡿⡛⠿⣟⠯⣟⠫⢟⠻⢿⡛⢽⡛⠽⡛⠯⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⠹⡄⠘⡆⠈⢆⠈⢣⠀⢳⡀⠀⢳⡀⠹⡇⠙⡆⠈⢆⠈⢧⠀⢳⡀⠱⡀⠙⡄⠘⣆⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢦⠀⢱⠀⢸⡀⠘⡄⠈⡇⠀⣇⠀⠀⢧⠀⣷⠀⢸⠀⠸⡄⠈⡆⠀⣇⠀⢣⠀⢹⠀⠈⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢸⡀⠘⡆⠀⡇⠀⢇⠀⢹⠀⢸⠀⠀⢸⠀⡟⡆⠀⡇⠀⣇⠀⢳⠀⢸⠀⠸⡀⠈⡇⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⡇⠀⣇⠀⢳⠀⢸⠀⠸⡀⠈⡇⠀⠀⡇⡇⡇⠀⢳⠀⢸⠀⢸⡀⠈⡆⠀⡇⠀⢧⠀⠀⠀⠀⠀│
      │⠤⠤⠤⠤⠤⢧⠤⢼⠤⢼⠤⠼⡦⠤⡧⠤⣧⠤⠤⢧⡧⢼⠤⢼⠤⠼⡤⠤⡧⠤⡧⠤⢷⠤⢼⠤⠤⠤⠤⠤│
      │⠀⠀⠀⠀⠀⢸⠀⠸⡄⠀⡇⠀⡇⠀⢳⠀⢸⠀⠀⢸⡇⠸⡄⠈⡇⠀⡇⠀⢧⠀⢸⠀⢸⠀⠘⡆⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⠈⡇⠀⡇⠀⢧⠀⢹⠀⢸⡀⠘⡆⠀⠘⡇⠀⡇⠀⢧⠀⢹⠀⢸⠀⠸⡄⠈⡇⠀⣇⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢆⠀⢳⠀⢸⠀⠸⡄⠘⡆⠀⣇⠀⢧⠀⠀⣧⠀⢹⠀⠸⡀⠘⡆⠀⣇⠀⢧⠀⢳⠀⠘⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠘⣆⠈⢆⠀⢧⡀⢳⡀⠹⡄⠘⣄⠘⣆⠀⡏⢆⠀⢧⠀⢳⡀⠹⡀⠸⣄⠘⣆⠈⢧⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠐⣬⣗⣮⣷⣦⣵⣢⣽⣲⣽⣶⣬⣗⣬⣗⣧⣬⣓⣦⣵⣢⣽⣲⣽⣶⣬⣖⣬⣗⣮⡵⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
      └────────────────────────────────────────┘
      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀

julia&gt; gt = ground_track(orbp, track_types = :descending);

julia&gt; lineplot(last.(gt), first.(gt))
      ┌────────────────────────────────────────┐
    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⣸⡽⠟⣻⠽⣻⠿⢛⡯⢛⡯⢟⡻⠝⣻⠝⣿⠽⢛⠯⢛⡯⢛⡿⠟⡻⠝⣻⠽⣻⠿⢓⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠞⠀⡼⠁⣰⠃⢰⠋⢠⠏⢀⡞⠀⡜⠁⡼⡇⣰⠃⢠⠏⢀⠎⠀⡞⠀⡼⠁⣰⠃⢰⣫⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⢰⠃⢠⠇⠀⡏⠀⡞⠀⡸⠀⢸⠁⢰⠃⣇⡇⠀⡏⠀⡼⠀⣸⠀⢰⠃⢠⠇⠀⣏⠇⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⡞⠀⣸⠀⢸⠁⢠⠃⠀⡇⠀⡏⠀⡼⠀⣿⠀⢰⠁⢀⡇⠀⡇⠀⡞⠀⣸⠀⢸⢸⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢀⡇⠀⡇⠀⡜⠀⢸⠀⢸⠁⢠⠇⠀⡇⠀⡏⠀⣸⠀⢸⠀⢰⠃⢀⡇⠀⡇⠀⡜⡏⠀⠀⠀⠀⠀│
      │⠤⠤⠤⠤⢼⠤⢤⠧⠤⡧⠤⡯⠤⡼⠤⢼⠤⢴⠥⢤⡧⠤⡧⠤⡾⠤⢼⠤⢼⠤⢤⠧⠤⣧⠧⠤⠤⠤⠤⠤│
      │⠀⠀⠀⠀⡼⠀⢸⠀⢸⠁⢀⠇⠀⡇⠀⡞⠀⢸⠀⢸⡇⢠⠃⠀⡇⠀⡏⠀⡼⠀⢸⠀⢸⢹⠀⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠁⠀⡎⠀⡸⠀⢸⠀⢰⠃⢀⡇⠀⡇⠀⡜⡇⣸⠀⢸⠁⢠⠇⠀⡇⠀⡎⠀⡸⡞⠀⣰⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⢰⠃⢀⠇⠀⡏⠀⡼⠀⣸⠀⢰⠁⢠⠇⣇⡇⠀⡞⠀⡼⠀⢸⠁⢰⠃⢀⢧⠇⢀⡇⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢀⠎⢀⡞⠀⡼⠁⡰⠃⣠⠃⢠⠏⢀⡞⢀⡿⠀⡼⠁⣰⠃⢠⠇⢀⠎⢀⡞⠀⢀⡜⠀⠀⠀⠀⠀│
      │⠀⠀⠀⠀⢩⣖⣯⣔⣮⣴⣾⣥⣺⣥⣲⣥⣖⣯⣔⣯⣷⣾⣵⣺⣥⣲⣥⣶⣯⣖⣋⣤⣔⣯⣔⣎⠀⠀⠀⠀│
      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
      └────────────────────────────────────────┘
      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/ground_track.jl#L9-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.ground_track_inclination-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}" href="#SatelliteAnalysis.ground_track_inclination-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>SatelliteAnalysis.ground_track_inclination</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ground_track_inclination(a::Number, e::Number, i::Number; kwargs...) -&gt; T
ground_track_inclination(orb::Orbit{Tepoch, T}); kwargs...) where {Tepoch &lt;: Number, T &lt;: Number} -&gt; T</code></pre><p>Compute the ground track inclination at the Equator [rad] in an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code> [ ], and inclination <code>i</code> [rad]. The orbit can also be specified by <code>orb</code> (see <code>Orbit</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The output type <code>T</code> in the first signature is obtained by promoting the inputs to a float type.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The algorithm here assumes a small orbit eccentricity.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>perturbation::Symbol</code>: Symbol to select the perturbation terms that will be used. It can   be <code>:J0</code>, <code>:J2</code>, or <code>:J4</code>.   (<strong>Default</strong>: <code>:J2</code>)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong>: <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong>: <code>EGM_2008_J2</code>)</li><li><code>J4::Number</code>: J₄ perturbation term.   (<strong>Default</strong>: <code>EGM_2008_J4</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong>: <code>EARTH_EQUATORIAL_RADIUS</code>)</li><li><code>we::Number</code>: Earth&#39;s angular speed [rad / s].   (<strong>Default</strong>: <code>EARTH_ANGULAR_SPEED</code>)</li></ul><p><strong>Extended Help</strong></p><p>We define the ground track inclination as the angle that the ground track has with respect to the Equator. This information is important to compute, for example, the required swath for a remote sensing satellite to cover the entire Earth.</p><p>The ground track inclination <code>i_gt</code> is given by:</p><pre><code class="nohighlight hljs">            ┌                       ┐
            │      ω_s ⋅ sin i      │
i_gt = atan │ ───────────────────── │
            │ ω_s ⋅ cos i - ω_e + Ω̇ │
            └                       ┘</code></pre><p>where <code>ω_s = n + ω̇</code> is the satellite angular velocity, <code>n</code> is the perturbed mean motion, <code>i</code> is the orbit inclination, <code>ω</code> is the orbit argument of perigee, <code>Ω</code> is the orbit right ascension of the ascending node, and <code>ω_e</code> is the Earth&#39;s angular rate.</p><p>Formally, we should use the satellite instantaneous angular speed at the Equator instead of the mean angular speed <code>ω_s</code>. However, given the perturbations caused by the Earth&#39;s gravitational potential, the former is not simple to compute. This calculation would required to implement an orbit propagator here. Thus, we simplify it by assuming that the orbit eccentricity is small. This assumption is reasonable given the missions that would benefit from the computation of the ground track inclination. In this case, the orbit angular speed is almost constant and equal to <code>ω_s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis

julia&gt; ground_track_inclination(7130.982e3, 0.00111, 98.410 |&gt; deg2rad) |&gt; rad2deg
102.30052101661899

julia&gt; jd₀ = date_to_jd(2021, 1, 1)
2.4592155e6

julia&gt; orb = KeplerianElements(
           jd₀,
           7130.982e3,
           0.001111,
           98.410 |&gt; deg2rad,
           ltdn_to_raan(10.5, jd₀),
           π / 2,
           0
       )
KeplerianElements{Float64, Float64}:
           Epoch :    2.45922e6 (2021-01-01T00:00:00)
 Semi-major axis : 7130.98     km
    Eccentricity :    0.001111
     Inclination :   98.41     °
            RAAN :   78.4021   °
 Arg. of Perigee :   90.0      °
    True Anomaly :    0.0      °

julia&gt; ground_track_inclination(orb) |&gt; rad2deg
102.30052101658998</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/ground_track.jl#L214-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.is_ground_facility_visible-Tuple{AbstractVector, Vararg{Number, 4}}" href="#SatelliteAnalysis.is_ground_facility_visible-Tuple{AbstractVector, Vararg{Number, 4}}"><code>SatelliteAnalysis.is_ground_facility_visible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_ground_facility_visible(sat_r_e::AbstractVector, gf_lat::Number, gf_lon::Number, gf_h::Number, θ::Number) -&gt; Bool
is_ground_facility_visible(sat_r_e::AbstractVector, gf_r_e::AbstractVector, θ::Number) -&gt; Bool
is_ground_facility_visible(sat_r_ned::AbstractVector, θ::Number) -&gt; Bool</code></pre><p>Check if the satellite with position vector <code>sat_r_e</code> (ECEF) is inside the visibility circle of a ground facility with latitude <code>gf_lat</code> [rad], longitude <code>gf_lon</code> [rad], altitude <code>gf_h</code> (WGS-84) or ECEF position <code>gf_r_e</code> [m]. The algorithm considers that the ground station has visibility to the satellite if its elevation angle is larger than <code>θ</code> [rad].</p><p>The user can also pass the satellite position represented in the NED (North-East-Down) reference frame <code>sat_r_ned</code> [m] at the ground station location, which increases the performance since the algorithm performs no reference frame conversion.</p><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the satellite is inside the visibility circle, or <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/ground_facilities/is_ground_facility_visible.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.lighting_condition-Tuple{AbstractVector, AbstractVector}" href="#SatelliteAnalysis.lighting_condition-Tuple{AbstractVector, AbstractVector}"><code>SatelliteAnalysis.lighting_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lighting_condition(r_i::AbstractVector, s_i::AbstractVector)</code></pre><p>Compute the lighting condition at the position <code>r_i</code> [m] considering the Sun position vector <code>s_i</code> [m]. The possible return values are:</p><ul><li><code>:sunlight</code>: The point is under direct sunlight.</li><li><code>:penumbra</code>: The point is in penumbra region.</li><li><code>:umbra</code>: The point is in umbra region.</li></ul><p>The algorithm used in this function was based on <strong>[1]</strong>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The vectors <code>r_i</code> and <code>s_i</code> must be represented in the same reference frame.</p></div></div><p><strong>References</strong></p><ul><li><strong>[1]</strong> Longo, C. R. O., Rickman, S. L (1995). Method for the Calculation of Spacecraft   Umbra and Penumbra Shadow Terminator Points. NASA Technical Paper 3547.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/lighting_condition.jl#L14-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.plot_ground_facility_visibility_circles!-Tuple" href="#SatelliteAnalysis.plot_ground_facility_visibility_circles!-Tuple"><code>SatelliteAnalysis.plot_ground_facility_visibility_circles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_ground_facility_visibility_circles!(ax::Axis, vgf_vc::Vector{Vector{NTuple{2, Number}}}; kwargs...) -&gt; Nothing</code></pre><p>Plot in the <strong>Makie.jl</strong> axis <code>ax</code> the ground facility visibility circles in the vector <code>vgf_vc</code>, where each element is computed using the function <a href="#SatelliteAnalysis.ground_facility_visibility_circle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Tuple{T1, T2, T3}, Number}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>ground_facility_visibility_circle</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function <strong>only works</strong> after loading the package <strong>GeoMakie.jl</strong>. Furthermore, the user must also load one Makie.jl back end (CairoMakie.jl or GLMakie.jl, for example) to see the result.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>ground_facility_names::Union{Nothing, Vector{String}}</code>: The user can provide a vector of   <code>String</code>s with the length of <code>vgf_vc</code> to be plotted with the visibility circles. If this   parameter is <code>nothing</code>, no ground facility name is added to the figure.   (<strong>Default</strong> = <code>nothing</code>)</li></ul><p><strong>Extended Help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using SatelliteAnalysis, GeoMakie, GLMakie

julia&gt; gfv1 = ground_facility_visibility_circle((0, 0, 0), EARTH_EQUATORIAL_RADIUS + 700e3);

julia&gt; gfv2 = ground_facility_visibility_circle((-40 |&gt; deg2rad, -60 |&gt; deg2rad, 0), EARTH_EQUATORIAL_RADIUS + 700e3);

julia&gt; fig = Figure(size = (1000, 1000))

julia&gt; ax = Axis(fig[1, 1])

julia&gt; plot_ground_facility_visibility_circles!(
           ax,
           [gfv1, gfv2];
           ground_facility_names = [&quot;GF 1&quot;, &quot;GF 2&quot;]
       )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/plotting/ground_facilities.jl#L65-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.plot_ground_facility_visibility_circles-Tuple" href="#SatelliteAnalysis.plot_ground_facility_visibility_circles-Tuple"><code>SatelliteAnalysis.plot_ground_facility_visibility_circles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_ground_facility_visibility_circles(vgf_vc::Vector{Vector{NTuple{2, Number}}}; kwargs...) -&gt; Figure, Axis</code></pre><p>Plot the ground facility visibility circles in the vector <code>vgf_vc</code>, where each element is computed using the function <a href="#SatelliteAnalysis.ground_facility_visibility_circle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Tuple{T1, T2, T3}, Number}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>ground_facility_visibility_circle</code></a>. It returns the objects <code>Figure</code> and <code>Axis</code> used to plot the data. For more information, please, refer to <strong>Makie.jl</strong> documentation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function plots the countries&#39; borders in the created figure using the file with the country polygons fetched with the function <a href="#SatelliteAnalysis.fetch_country_polygons"><code>fetch_country_polygons</code></a>. Hence, if this files does not exist, the algorithm tries to download it.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function <strong>only works</strong> after loading the package <strong>GeoMakie.jl</strong>. Furthermore, the user must also load one Makie.jl back end (CairoMakie.jl or GLMakie.jl, for example) to see the result.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>ground_facility_names::Union{Nothing, Vector{String}}</code>: The user can provide a vector of   <code>String</code>s with the length of <code>vgf_vc</code> to be plotted with the visibility circles. If this   parameter is <code>nothing</code>, no ground facility name is added to the figure.   (<strong>Default</strong> = <code>nothing</code>)</li></ul><p>All other <code>kwargs...</code> are passed to the function <a href="#SatelliteAnalysis.plot_world_map-Tuple"><code>plot_world_map</code></a>.</p><p><strong>Extended Help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using SatelliteAnalysis, GeoMakie, GLMakie

julia&gt; gfv1 = ground_facility_visibility_circle((0, 0, 0), EARTH_EQUATORIAL_RADIUS + 700e3);

julia&gt; gfv2 = ground_facility_visibility_circle((-40 |&gt; deg2rad, -60 |&gt; deg2rad, 0), EARTH_EQUATORIAL_RADIUS + 700e3);

julia&gt; fig, ax = plot_ground_facility_visibility_circles(
           [gfv1, gfv2];
           ground_facility_names = [&quot;GF 1&quot;, &quot;GF 2&quot;]
       )
(Scene (1600px, 800px):
  0 Plots
  1 Child Scene:
    └ Scene (1600px, 800px), Axis (7 plots))

julia&gt; fig</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/plotting/ground_facilities.jl#L9-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.plot_ground_track!-Tuple" href="#SatelliteAnalysis.plot_ground_track!-Tuple"><code>SatelliteAnalysis.plot_ground_track!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_ground_track!(ax:Axis, gt::Vector{NTuple{2, Number}}) -&gt; Nothing</code></pre><p>Plot in the <strong>Makie.jl</strong> axis <code>ax</code> the ground track <code>gt</code> computed using the function <a href="#SatelliteAnalysis.ground_track-Tuple{OrbitPropagator}"><code>ground_track</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function <strong>only works</strong> after loading the package <strong>GeoMakie.jl</strong>. Furthermore, the user must also load one Makie.jl back end (CairoMakie.jl or GLMakie.jl, for example) to see the result.</p></div></div><p><strong>Extended Help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis, GeoMakie, GLMakie

julia&gt; jd₀ = date_to_jd(2021, 1, 1)
2.4592155e6

julia&gt; orb = KeplerianElements(
           jd₀,
           7130.982e3,
           0.001111,
           98.405 |&gt; deg2rad,
           ltdn_to_raan(10.5, jd₀),
           π / 2,
           0
       )
KeplerianElements{Float64, Float64}:
           Epoch :    2.45922e6 (2021-01-01T00:00:00)
 Semi-major axis : 7130.98     km
    Eccentricity :    0.001111
     Inclination :   98.405    °
            RAAN :   78.4021   °
 Arg. of Perigee :   90.0      °
    True Anomaly :    0.0      °

julia&gt; orbp = Propagators.init(Val(:J2), orb)
OrbitPropagatorJ2{Float64, Float64}:
   Propagator name : J2 Orbit Propagator
  Propagator epoch : 2021-01-01T00:00:00
  Last propagation : 2021-01-01T00:00:00

julia&gt; gt = ground_track(orbp; track_types = :descending, duration = 5 * 86400);


julia&gt; fig = Figure(size = (1000, 1000))

julia&gt; ax = Axis(fig[1, 1])

julia&gt; plot_ground_track!(ax, gt)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/plotting/ground_track.jl#L79-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.plot_ground_track-Tuple{Any}" href="#SatelliteAnalysis.plot_ground_track-Tuple{Any}"><code>SatelliteAnalysis.plot_ground_track</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_ground_track(gt::Vector{NTuple{2, Number}}; kwargs...) -&gt; Figure, Axis</code></pre><p>Plot the ground track <code>gt</code> computed using the function <a href="#SatelliteAnalysis.ground_track-Tuple{OrbitPropagator}"><code>ground_track</code></a>. It returns the objects <code>Figure</code> and <code>Axis</code> used to plot the data. For more information, please, refer to <strong>Makie.jl</strong> documentation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function plots the countries&#39; borders in the created figure using the file with the country polygons fetched with the function <a href="#SatelliteAnalysis.fetch_country_polygons"><code>fetch_country_polygons</code></a>. Hence, if this files does not exist, the algorithm tries to download it.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function <strong>only works</strong> after loading the package <strong>GeoMakie.jl</strong>. Furthermore, the user must also load one Makie.jl back end (CairoMakie.jl or GLMakie.jl, for example) to see the result.</p></div></div><p>All <code>kwargs...</code> are passed to the function <a href="#SatelliteAnalysis.plot_world_map-Tuple"><code>plot_world_map</code></a>.</p><p><strong>Extended Help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis, GeoMakie, GLMakie

julia&gt; jd₀ = date_to_jd(2021, 1, 1)
2.4592155e6

julia&gt; orb = KeplerianElements(
           jd₀,
           7130.982e3,
           0.001111,
           98.405 |&gt; deg2rad,
           ltdn_to_raan(10.5, jd₀),
           π / 2,
           0
       )
KeplerianElements{Float64, Float64}:
           Epoch :    2.45922e6 (2021-01-01T00:00:00)
 Semi-major axis : 7130.98     km
    Eccentricity :    0.001111
     Inclination :   98.405    °
            RAAN :   78.4021   °
 Arg. of Perigee :   90.0      °
    True Anomaly :    0.0      °

julia&gt; orbp = Propagators.init(Val(:J2), orb)
OrbitPropagatorJ2{Float64, Float64}:
   Propagator name : J2 Orbit Propagator
  Propagator epoch : 2021-01-01T00:00:00
  Last propagation : 2021-01-01T00:00:00

julia&gt; gt = ground_track(orbp; track_types = :descending, duration = 5 * 86400);

julia&gt; fig, ax = plot_ground_track(gt; size = (2000, 1000))
(Scene (2000px, 1000px):
  0 Plots
  1 Child Scene:
    └ Scene (2000px, 1000px), Axis (2 plots))

julia&gt; fig</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/plotting/ground_track.jl#L9-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.plot_world_map-Tuple" href="#SatelliteAnalysis.plot_world_map-Tuple"><code>SatelliteAnalysis.plot_world_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_world_map(; kwargs...) -&gt; Figure, Axis</code></pre><p>Create a <strong>Makie.jl</strong> <code>Figure</code> and <code>Axis</code> with the world map. All the <code>kwargs...</code> are passed to the function <code>Figure</code>. For more information, please, refer to <strong>Makie.jl</strong> documentation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function plots the countries&#39; borders in the created figure using the file with the country polygons fetched with the function <a href="#SatelliteAnalysis.fetch_country_polygons"><code>fetch_country_polygons</code></a>. Hence, if this files does not exist, the algorithm tries to download it.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/plotting/world_map.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.sun_sync_orbit_from_angular_velocity-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Number, T2&lt;:Number}" href="#SatelliteAnalysis.sun_sync_orbit_from_angular_velocity-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Number, T2&lt;:Number}"><code>SatelliteAnalysis.sun_sync_orbit_from_angular_velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sun_sync_orbit_from_angular_velocity(angvel::T1, e::T2 = 0; kwargs...) where {T1 &lt;: Number, T2 &lt;: Number} -&gt; T, T, Bool</code></pre><p>Compute the Sun-synchronous orbit semi-major axis [m] and inclination [rad] given the angular velocity <code>angvel</code> [rad / s] and the orbit eccentricity <code>e</code> [ ]. If the latter is omitted, the orbit is considered circular, i.e., <code>e = 0</code>.</p><p>The algorithm here considers only the perturbation terms up to J₂.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Internally, this function uses the precision obtained by promoting <code>T1</code> and <code>T2</code> to a float-pointing number <code>T</code>.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>max_iterations::Number</code>: Maximum number of iterations in the Newton-Raphson method.   (<strong>Default</strong> = 3)</li><li><code>no_warnings::Bool</code>: If <code>true</code>, no warnings will be printed.   (<strong>Default</strong> = <code>false</code>)</li><li><code>tolerance::Union{Nothing, NTuple{2, Number}}</code>: Residue tolerances to verify if the   numerical method has converged. If it is <code>nothing</code>, <code>(√eps(T), √eps(T))</code> will be used,   where <code>T</code> is the internal type for the computations. Notice that the residue function   <code>f₁</code> unit is [deg / day], whereas the <code>f₂</code> unit is [deg / min].   (<strong>Default</strong> = 1e-18)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong> = <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong> = <code>EGM_2008_J2</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong> = <code>EARTH_EQUATORIAL_RADIUS</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>T</code>: Semi-major axis [m].</li><li><code>T</code>: Inclination [rad].</li><li><code>Bool</code>: <code>true</code> if the Newton-Raphson algorithm converged, or <code>false</code> otherwise.</li></ul><p><strong>Extended help</strong></p><p>A Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth&#39;s orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.</p><p>The RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:</p><pre><code class="nohighlight hljs">∂Ω      3                       n̄
── = - ─── R₀² . J₂ . cos(i) . ─── .
∂t      2                       p²</code></pre><p>where:</p><pre><code class="nohighlight hljs">         ┌                                                ┐
         │      3    R₀²                                  │
n̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.
         │      4     p²                                  │
         └                                                ┘</code></pre><p>We can express the orbit angular velocity in terms of its nodal period, i.e., the period it takes for the satellite to cross the ascending node two consecutive times:</p><pre><code class="nohighlight hljs">          ∂M     ∂ω
angvel = ──── + ────,
          ∂t     ∂t

                  3    R₀²
angvel = n̄ + n̄ . ─── . ─── . J₂ . (4 - 5sin²(i)),
                  4     p²</code></pre><p>where <code>n</code> is the perturbed mean motion due to the same consideration as presented for the RAAN time-derivative.</p><p>Finally, this function finds the pair <code>(a, i)</code> that simultaneously solves the equations:</p><pre><code class="nohighlight hljs">∂Ω
── (a, i) = EARTH_ORBIT_MEAN_MOTION,
∂t

 ∂M            ∂ω
──── (a, i) + ──── (a, i) = angvel,
 ∂t            ∂t</code></pre><p>using the Newton-Raphson method with the presented equations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis

julia&gt; sun_sync_orbit_from_angular_velocity(0.06 |&gt; deg2rad)
(7.130983932846816e6, 1.7175898375139984, true)

julia&gt; sun_sync_orbit_from_angular_velocity(0.06 |&gt; deg2rad, 0)
(7.130983932846816e6, 1.7175898375139984, true)

julia&gt; sun_sync_orbit_from_angular_velocity(0.06 |&gt; deg2rad, 0.1)
(7.13086251587883e6, 1.7146410689929386, true)</code></pre><p>The user can verify some internal information of the solver by turning on the debugging logs:</p><pre><code class="language-julia-repl hljs">julia&gt; with_logger(ConsoleLogger(stderr, Logging.Debug)) do
           sun_sync_orbit_from_angular_velocity(0.06 |&gt; deg2rad)
       end
┌ Debug: Iteration #1
│   Estimation :
│     a  = 7136.635455699327 km
│     i  = 81.57099271530629 °
│   Residues :
│     f₁ = 1.9706966881670205 ° / day
│     f₂ = 0.004266929859281898 ° / min
└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394
┌ Debug: Iteration #2
│   Estimation :
│     a  = 7128.856266265137 km
│     i  = 98.46515928332974 °
│   Residues :
│     f₁ = -0.0073785260175135425 ° / day
│     f₂ = -0.0016144146737784304 ° / min
└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394
┌ Debug: Iteration #3
│   Estimation :
│     a  = 7130.983594940013 km
│     i  = 98.41070350863473 °
│   Residues :
│     f₁ = -6.549620124363109e-6 ° / day
│     f₂ = -2.6066638092459016e-7 ° / min
└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394
┌ Debug: Iteration #4
│   Estimation :
│     a  = 7130.983932846698 km
│     i  = 98.41064862339992 °
│   Residues :
│     f₁ = 8.290634845309341e-11 ° / day
│     f₂ = -2.2648549702353193e-14 ° / min
└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394
(7.130983932846816e6, 1.7175898375139984, true)</code></pre><p><strong>References</strong></p><ul><li><strong>[1]</strong> Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/sun_synchronous_orbits.jl#L237-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.sun_sync_orbit_inclination-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Number, T2&lt;:Number}" href="#SatelliteAnalysis.sun_sync_orbit_inclination-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Number, T2&lt;:Number}"><code>SatelliteAnalysis.sun_sync_orbit_inclination</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sun_sync_orbit_inclination(a::T1, e::T2 = 0; kwargs...) where {T1 &lt;: Number, T2 &lt;: Number} -&gt; T, Bool</code></pre><p>Compute the inclination [rad] of the Sun-synchronous orbit with semi-major axis <code>a</code> [m] and the eccentricity <code>e</code> [ ]. If the latter is omitted, the orbit is considered circular, i.e., <code>e = 0</code>.</p><p>The algorithm here considers only the perturbation terms up to J₂.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Internally, this function uses the precision obtained by promoting <code>T1</code> and <code>T2</code> to a float-pointing number <code>T</code>.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>max_iterations::Number</code>: Maximum number of iterations in the Newton-Raphson method.   (<strong>Default</strong> = 30)</li><li><code>tolerance::Union{Nothing, Number}</code>: Residue tolerance to verify if the numerical method   has converged. If it is <code>nothing</code>, <code>√eps(T)</code> will be used, where <code>T</code> is the internal   type for the computations. Notice that the residue unit is [deg / day].   (<strong>Default</strong> = nothing)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong> = <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong> = <code>EGM_2008_J2</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong> = <code>EARTH_EQUATORIAL_RADIUS</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>T</code>: Inclination [rad] of the Sun-synchronous orbit with semi-major axis <code>a</code> and   eccentricity <code>e</code>.</li><li><code>Bool</code>: <code>true</code> if the Newton-Raphson algorithm converged, or <code>false</code> otherwise.</li></ul><p><strong>Extended help</strong></p><p>A Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth&#39;s orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.</p><p>The RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:</p><pre><code class="nohighlight hljs">∂Ω      3                       n̄
── = - ─── R₀² . J₂ . cos(i) . ─── .
∂t      2                       p²</code></pre><p>where:</p><pre><code class="nohighlight hljs">         ┌                                                ┐
         │      3    R₀²                                  │
n̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.
         │      4     p²                                  │
         └                                                ┘</code></pre><p>Finally, this function solves the equation:</p><pre><code class="nohighlight hljs">∂Ω
── (i) = EARTH_ORBIT_MEAN_MOTION
∂t</code></pre><p>for <code>i</code> using the Newton-Raphson method with the presented equations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis

julia&gt; sun_sync_orbit_inclination(7130.982e3)
(1.7175896973066611, true)

julia&gt; sun_sync_orbit_inclination(7130.982e3, 0)
(1.7175896973066611, true)

julia&gt; sun_sync_orbit_inclination(7130.982e3, 0.001111)
(1.7175893324980402, true)</code></pre><p>The user can verify some internal information of the solver by turning on the debugging logs:</p><pre><code class="language-julia hljs">julia&gt; with_logger(ConsoleLogger(stderr, Logging.Debug)) do
           sun_sync_orbit_inclination(7130.982e3)
       end
┌ Debug: Iteration #1
│   Estimation : 98.41064059121584 °
│   Residue    : 0.0005992085524891833 ° / day
└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:686
┌ Debug: Iteration #2
│   Estimation : 98.41064059082426 °
│   Residue    : -4.556321986370904e-11 ° / day
└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:686
(1.7175896973066611, true)</code></pre><p><strong>References</strong></p><ul><li><strong>[1]</strong> Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/sun_synchronous_orbits.jl#L782-L888">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SatelliteAnalysis.sun_sync_orbit_semi_major_axis-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Number, T2&lt;:Number}" href="#SatelliteAnalysis.sun_sync_orbit_semi_major_axis-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1&lt;:Number, T2&lt;:Number}"><code>SatelliteAnalysis.sun_sync_orbit_semi_major_axis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sun_sync_orbit_semi_major_axis(i::T1, e::T2 = 0; kwargs...) where {T1 &lt;: Number, T2 &lt;: Number} -&gt; T, Bool</code></pre><p>Compute the semi-major axis [m] of the Sun-synchronous orbit with inclination <code>i</code> [rad] and the eccentricity <code>e</code> [ ]. If the latter is omitted, the orbit is considered circular, i.e., <code>e = 0</code>.</p><p>The algorithm here considers only the perturbation terms up to J₂.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Internally, this function uses the precision obtained by promoting <code>T1</code> and <code>T2</code> to a float-pointing number <code>T</code>.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>max_iterations::Number</code>: Maximum number of iterations in the Newton-Raphson method.   (<strong>Default</strong> = 30)</li><li><code>tolerance::Union{Nothing, Number}</code>: Residue tolerance to verify if the numerical method   has converged. If it is <code>nothing</code>, <code>√eps(T)</code> will be used, where <code>T</code> is the internal   type for the computations. Notice that the residue unit is [deg / day].   (<strong>Default</strong> = nothing)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong> = <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong> = <code>EGM_2008_J2</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong> = <code>EARTH_EQUATORIAL_RADIUS</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>T</code>: Semi-major axis [m] of the Sun-synchronous orbit with inclination <code>i</code> and   eccentricity <code>e</code>.</li><li><code>Bool</code>: <code>true</code> if the Newton-Raphson algorithm converged, or <code>false</code> otherwise.</li></ul><p><strong>Extended help</strong></p><p>A Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth&#39;s orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.</p><p>The RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:</p><pre><code class="nohighlight hljs">∂Ω      3                       n̄
── = - ─── R₀² . J₂ . cos(i) . ─── .
∂t      2                       p²</code></pre><p>where:</p><pre><code class="nohighlight hljs">         ┌                                                ┐
         │      3    R₀²                                  │
n̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.
         │      4     p²                                  │
         └                                                ┘</code></pre><p>Finally, this function solves the equation:</p><pre><code class="nohighlight hljs">∂Ω
── (a) = EARTH_ORBIT_MEAN_MOTION
∂t</code></pre><p>for <code>a</code> using the Newton-Raphson method with the presented equations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SatelliteAnalysis

julia&gt; sun_sync_orbit_semi_major_axis(98.410 |&gt; deg2rad)
(7.130827866508738e6, true)

julia&gt; sun_sync_orbit_semi_major_axis(98.410 |&gt; deg2rad, 0)
(7.130827866508738e6, true)

julia&gt; sun_sync_orbit_semi_major_axis(98.410 |&gt; deg2rad, 0.001111)
(7.1308328955274355e6, true)</code></pre><p>The user can verify some internal information of the solver by turning on the debugging logs:</p><pre><code class="language-julia-repl hljs">julia&gt; with_logger(ConsoleLogger(stderr, Logging.Debug)) do
           sun_sync_orbit_semi_major_axis(98.41064163374567 |&gt; deg2rad)
       end
┌ Debug: Iteration #1
│   Estimation : 7130.981820550704 km
│   Residue    : 0.0005989504045072862 ° / day
└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559
┌ Debug: Iteration #2
│   Estimation : 7130.982250931794 km
│   Residue    : -2.081337784770338e-7 ° / day
└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559
┌ Debug: Iteration #3
│   Estimation : 7130.982250931845 km
│   Residue    : -2.4312691616901194e-14 ° / day
└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559
(7.130982250931845e6, true)</code></pre><p><strong>References</strong></p><ul><li><strong>[1]</strong> Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/120f4b2d9b4c2842a0508ed7bbe2423f1c45c6bc/src/sun_synchronous_orbits.jl#L548-L658">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/orbits/sun_synchronous_orbits/">« Sun Synchronous Orbits</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 4 July 2024 14:10">Thursday 4 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
