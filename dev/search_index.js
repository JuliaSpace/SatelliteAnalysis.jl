var documenterSearchIndex = {"docs":
[{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/","page":"Library","title":"Library","text":"Documentation for SatelliteAnalysis.jl.","category":"page"},{"location":"lib/library/","page":"Library","title":"Library","text":"Modules = [SatelliteAnalysis]","category":"page"},{"location":"lib/library/#SatelliteAnalysis.beta_angle-Tuple{KeplerianElements, Number}","page":"Library","title":"SatelliteAnalysis.beta_angle","text":"beta_angle(orb::KerplerianElements{Tepoch, T}, Δjd::Number; kwargs...) -> Float64\n\nCompute the beta angle [rad] for the orbit orb after Δjd days from its epoch.\n\nThe algorithm was obtained from [1].\n\nnote: Note\nIt is expected that the input elements are represented in the TOD reference frame. If it is not the case, they can be converted using the function orb_eci_to_eci of SatelliteToolboxTransformations.jl.\n\nKeywords\n\nperturbation::Symbol: Select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J₂.\n:J4: Consider the perturbation terms J₂, J₂², and J₄.\n(Default: :J2)\n\nReferences\n\n[1]: Mortari, D., Wilkins, M. P., and Bruccoleri, C.  On Sun-Synchronous Orbits and   Associated Constellations\n\nExtended Help\n\nThe beta angle is the angle between the orbit plane and the Sun. The positive direction is defined as that of the orbit angular momentum.\n\nThe beta angle is useful when computing the mean amount of solar radiation a satellite receives in a particular orbit.\n\nExamples\n\njulia> using SatelliteAnalysis, UnicodePlots\n\njulia> jd₀ = date_to_jd(2021, 1, 1, 0, 0, 0)\n\njulia> orb = KeplerianElements(\n            jd₀,\n            7130.982e3,\n            0.001111,\n            98.405 |> deg2rad,\n            ltdn_to_raan(10.5, jd₀),\n            90     |> deg2rad,\n            0\n        )\n\njulia> β = beta_angle.(orb, 0:1:364)\n\njulia> lineplot(0:1:364, rad2deg.(β), xlabel = \"Day\", ylabel = \"Beta angle [°]\")\n                     ┌────────────────────────────────────────┐\n                  30 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⣠⠞⠉⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⡴⠁⠀⠀⠀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠃⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠁⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⠀⠀⠀⠀⠀⠀⣠⠞⠀⠀⠀⠀⠀⠀│\n   Beta angle [°]    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠋⠀⠀⠀⠉⠓⠲⠤⠴⠚⠁⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣄⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠦⣄⣀⡠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                  10 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     └────────────────────────────────────────┘\n                     ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀400⠀\n                     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Day⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.design_sun_sync_ground_repeating_orbit-Tuple{Int64, Int64}","page":"Library","title":"SatelliteAnalysis.design_sun_sync_ground_repeating_orbit","text":"design_sun_sync_ground_repeating_orbit(minimum_repetition::Int, maximum_repetition::Int; kwargs...) -> DataFrame\n\nList all the Sun synchronous, ground repeating orbits in which their repetition period is in the interval [minimum_repetition, maximum_repetition] days.\n\nThis function returns a DataFrame with the following columns:\n\nsemi_major_axis: Orbit semi-major axis.\naltitude: Orbit altitude above the Equator (a - R0).\ninclination: Orbit inclination.\nperiod: Orbital period.\nrev_per_days: If the keyword pretify_rev_per_days is false, this column contains   Tuples with the integer and rational parts of the number of revolutions per day.   Otherwise, it contains a string with a prety representation of the number of revolutions   per day.\nadjacent_gt_distance: Distance between two adjacent ground tracks at Equator.\nadjacent_gt_angle: Angle between two adjacent ground tracks at Equator measured from the   satellite position.\n\nnote: Note\nThe units of those columns depends on the keywords.\n\nKeywords\n\nangle_unit::Symbol: Unit for all the angles in the output DataFrame.  It can be :deg   for degrees or :rad for radians.   (Default: :deg)\ndistance_unit::Symbol: The unit for all the distances in the output DataFrame. It can   be :m for meters or :km for kilometers.   (Default: :km)\ne::Number: Orbit eccentricity.   (Default: 0)\nint_rev_per_day::Tuple: Tuple with the integer parts of the number of revolutions per   day to be analyzed.   (Default = (13, 14, 15, 16, 17))\npretity_rev_per_days::Bool: If true, the column with the revolutions per day will be   conveted to a string with a pretty representation of this information.   (Default: true)\nmaximum_altitude::Union{Nothing, Number}: Maximum altitude [m] of the orbits in the   output DataFrame. If it is nothing, the algorithm will not apply a higher limit to   the orbital altitude.   (Default = nothing)\nminimum_altitude::Union{Nothing, Number}: Minimum altitude [m] of the orbits in the   output DataFrame. If it is nothing, the algorithm will not apply a lower limit to   the orbital altitude.   (Default = nothing)\ntime_unit::Symbol: Unit for all the time values in the output DataFrame.  It can be   :s for seconds, :m for minutes, or :h for hours.   (Default = :h)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.eclipse_time_summary-Tuple{OrbitPropagator}","page":"Library","title":"SatelliteAnalysis.eclipse_time_summary","text":"eclipse_time_summary(orbp::OrbitPropagator; kwargs...) -> DataFrame\n\nCompute the eclipse time summary for the orbit propagator orbp. The summary is computed as the total time the object stays in the sunlight, penumbra, and umbra regions per orbit at each day.\n\nKeywords\n\nnum_days::Number: Number of days in which the analysis will be performed.   (Default = 365)\nstep::Number: The step in which the propagation will occur. Notice that this function   has a crossing estimation to accurately estimate the transition between the regions.   However, if this step is very large, we may miss some small regions. If it is negative,   it will be selected as the time in which the mean anomaly advances 0.5°.   (Default = -1)\nunit::Symbol: Select the unit in which the results will be generated. The possible   values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.\n\nReturns\n\nDataFrame: The function returns a DataFrame with three columns:\nsunlight: Total sunlight time per orbit at each day [unit].\npenumbra: Total penumbra time per orbit at each day [unit].\numbra: Total umbra time per orbit at each day [unit].\nThe unit of each column is stored in the DataFrame using metadata.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> orb = KeplerianElements(\n           date_to_jd(2021, 1, 1, 0, 0, 0),\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           90     |> deg2rad,\n           0\n       )\n\njulia> orbp = Propagators.init(Val(:J2), orb)\n\njulia> df = eclipse_time_summary(orbp; num_days = 5)\n5×4 DataFrame\n Row │ date        sunlight  penumbra  umbra\n     │ Date        Float64   Float64   Float64\n─────┼─────────────────────────────────────────\n   1 │ 2021-01-01   3972.63   20.4117  2006.96\n   2 │ 2021-01-02   3973.85   20.4376  2005.71\n   3 │ 2021-01-03   3974.77   20.4575  2004.77\n   4 │ 2021-01-04   3975.74   20.4758  2003.79\n   5 │ 2021-01-05   3976.94   20.5022  2002.55\n\njulia> df = eclipse_time_summary(orbp; num_days = 5, unit = :m)\n5×4 DataFrame\n Row │ date        sunlight  penumbra  umbra\n     │ Date        Float64   Float64   Float64\n─────┼─────────────────────────────────────────\n   1 │ 2021-01-01   66.2105  0.340195  33.4493\n   2 │ 2021-01-02   66.2308  0.340627  33.4285\n   3 │ 2021-01-03   66.2461  0.340958  33.4129\n   4 │ 2021-01-04   66.2623  0.341263  33.3964\n   5 │ 2021-01-05   66.2824  0.341704  33.3759\n\njulia> colmetadata(df)\nDict{Symbol, Dict{String, Symbol}} with 3 entries:\n  :penumbra => Dict(\"Unit\"=>:m)\n  :sunlight => Dict(\"Unit\"=>:m)\n  :umbra    => Dict(\"Unit\"=>:m)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.find_crossing-Union{Tuple{N}, Tuple{Function, Number, Number, Any, Any, Vararg{Any, N}}} where N","page":"Library","title":"SatelliteAnalysis.find_crossing","text":"find_crossing(f::Function, t₀::Number, t₁::Number, s₀, s₁, vargs...; Δ = 1e-3, max = 100, kwargs...) -> T\n\nReturn the crossing time tc in which the function f(t) goes from the state s₀ to the state s₁. It is assumed that f(t₀) = s₀ and f(t₁) = s₁.\n\nThe parameters in vargs... are passed to the function f after t, and the keywords kwargs... are also passed to f. Hence, it will always be called as f(t, vargs...; kwargs...).\n\nIf the computed interval is smaller than Δ, or if the number of iterations is higher than max, the algorithm stops.\n\nnote: Note\nThe output type T is obtained by the type of (t₁ + t₂) / 2.\n\nExamples\n\njulia> SatelliteAnalysis.find_crossing(\n    t -> (sin(t) > 0),\n    -0.3,\n    0.3,\n    false,\n    true;\n    Δ = 1e-10\n)\n6.984919309616089e-11\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_facility_accesses-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_facility_accesses","text":"ground_facility_accesses(orbp, [(WGS84)]; kwargs...) -> DataFrame\n\nCompute the accesses of a satellite with orbit propagator orbp (see Propagators.init) to the ground facilities defined in the vector vgs_r_e. The analysis interval begins in the propagator epoch plus initial_time and lasts for duration [s], where both are keywords.\n\nThe ground facilities are specified using a vector of tuples with three numbers:\n\nTuple{T1, T2, T3} where {T1 <: Number, T2 <: Number, T3 <: Number}\n\ncontaining the WGS84 position of each ground facility [(WGS84)]:\n\n(latitude [rad], longitude [rad], altitude [m])\n\nThose geodetic information are transformed to an ECEF vector using the function geodetic_to_ecef.\n\nKeywords\n\nduration::Number: Duration of the analysis [s].   (Default = 86400)\nf_eci_to_ecef::Function: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be\njulia   f_eci_to_ecef(r_i::AbstractVector, jd::Number) -> AbstractVector\nand it must return the position vector r_i represented in the ECEF at the instant jd   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (Default: _ground_facility_default_eci_to_ecef)\ninitial_time::Number: Initial time of the analysis after the propagator epoch [s].   (Default = 0)\nminimum_elevation::Number: Minimum elevation angle for communication between the   satellite and the ground facilities [rad].   (Default = 10°)\nreduction::Function: A function that receives a boolean vector with the visibility   between the satellite and each ground facility. It must return a boolean value   indicating if the access must be computed or not. This is useful to merge access time   between two or more facilities.   (Default = v -> |(v...) i.e. compute the access if at least one ground   facilities is visible)\nstep::Number: The step [s] used to propagate the orbit. Notice that we perform a cross   tuning to accurately obtain the access time. However, if an access is lower than the   step, it can be neglected.   (Default = 60)\nunit::Symbol: Select the unit in which the duration will be computed. The possible   values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.\n\nReturns\n\nDataFrame: The function returns a DataFrame with three columns:\naccess_beginning: Time of the access beginning [UTC] encoded using DateTime.\naccess_end: Time of the access end [UTC] encoded using DateTime.\nduration: Duration of the access [s].\nThe unit of the column duration is stored in the DataFrame using metadata.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> jd₀ = date_to_jd(2024, 1, 1);\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       );\n\njulia> orbp = Propagators.init(Val(:J2), orb);\n\njulia> ground_facility_accesses(orbp, (0, 0, 0))\n2×3 DataFrame\n Row │ access_beginning         access_end               duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T10:20:03.136  2024-01-01T10:30:02.971   599.835\n   2 │ 2024-01-01T22:49:55.910  2024-01-01T22:59:23.470   567.56\n\njulia> ground_facility_accesses(orbp, (0, 0, 0); unit = :m)\n2×3 DataFrame\n Row │ access_beginning         access_end               duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T10:20:03.136  2024-01-01T10:30:02.971   9.99725\n   2 │ 2024-01-01T22:49:55.910  2024-01-01T22:59:23.470   9.45933\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_facility_gaps-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_facility_gaps","text":"ground_facility_gaps(orbp, args...; duration::Number = 86400, initial_time::Number = 0, kwargs...) -> DataFrame\n\nCompute the gaps between the accesses of ground facilities. The arguments and keywords are the same as the ones used in the function ground_facility_accesses.\n\nNotice that the gap analysis starts in the orbit propagator epoch plus initial_time and lasts for duration [s].\n\nReturns\n\nDataFrame: The function returns a DataFrame with three columns:\ngap_beginning: Time of the access beginning [UTC] encoded using DateTime.\ngap_end: Time of the access end [UTC] encoded using DateTime.\nduration: Duration of the access [s].\nThe unit of the column duration is stored in the DataFrame using metadata.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> jd₀ = date_to_jd(2024, 1, 1);\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       );\n\njulia> orbp = Propagators.init(Val(:J2), orb);\n\njulia> ground_facility_gaps(orbp, (0, 0, 0))\n3×3 DataFrame\n Row │ gap_beginning            gap_end                  duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T00:00:00      2024-01-01T10:20:03.136  37203.1\n   2 │ 2024-01-01T10:30:02.971  2024-01-01T22:49:55.910  44392.9\n   3 │ 2024-01-01T22:59:23.470  2024-01-02T00:00:00       3636.53\n\njulia> ground_facility_gaps(orbp, (0, 0, 0); unit = :m)\n3×3 DataFrame\n Row │ gap_beginning            gap_end                  duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T00:00:00      2024-01-01T10:20:03.136  620.052\n   2 │ 2024-01-01T10:30:02.971  2024-01-01T22:49:55.910  739.882\n   3 │ 2024-01-01T22:59:23.470  2024-01-02T00:00:00       60.6088\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_facility_visibility_circle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Tuple{T1, T2, T3}, Number}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_facility_visibility_circle","text":"ground_facility_visibility_circle(gf_wgs84::Tuple, satellite_position_norm::Number; kwargs...) -> Vector{NTuple{2, Float64}}\n\nCompute the ground facility visibility circle from the position gf_wgs84 (WGS84) to a satellite in which its distance from the Earth's center is satellite_position_norm [m]. It returns a vector of NTuple{2, Float64} where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the visibility circle.\n\nThe ground facility is specified using a tuple with its WGS84 position:\n\n(latitude [rad], longitude [rad], altitude [m])\n\nKeywords\n\nazimuth_step::Number: The step in the azimuth used to compute the visibility circle.   (Default: 0.1 |> deg2rad)\nminimum_elevation::Number: Minimum elevation angle for communication between the   satellite and the ground facility [rad].   (Default: 10 |> deg2rad)\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis, UnicodePlots\n\njulia> gfv = ground_facility_visibility_circle((0, 0, 0), EARTH_EQUATORIAL_RADIUS + 700e3);\n\njulia> lineplot(last.(gfv) .|> rad2deg, first.(gfv) .|> rad2deg; xlim = (-180, 180), ylim = (-90, 90))\n       ┌────────────────────────────────────────┐ \n    90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠚⠉⡏⠓⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠀⠀⠀⡇⠀⠀⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⡇⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢼⠤⠤⠤⠤⡧⠤⠤⠤⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⡇⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⡇⠀⠀⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⢤⣀⣇⡤⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   -90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       └────────────────────────────────────────┘ \n       ⠀-180⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀180⠀ \n\njulia> gfv = ground_facility_visibility_circle((-40 |> deg2rad, -60 |> deg2rad, 700), EARTH_EQUATORIAL_RADIUS + 700e3);\n\njulia> lineplot(last.(gfv) .|> rad2deg, first.(gfv) .|> rad2deg; xlim = (-180, 180), ylim = (-90, 90))\n       ┌────────────────────────────────────────┐ \n    90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤⡤⠤⠶⠤⣤⠤⠤⠤⠤⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠋⠀⠀⠀⠀⠈⠳⣄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠘⣆⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠳⢤⣀⠀⠀⠀⠀⠀⠀⢀⣀⡴⠃⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   -90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠉⠉⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       └────────────────────────────────────────┘ \n       ⠀-180⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀180⠀ \n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_repeating_orbit_adjacent_track_angle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_repeating_orbit_adjacent_track_angle","text":"ground_repeating_orbit_adjacent_track_angle(a::T1, e::T2, i::T3, orbit_cycle::Integer,) where {T1 <: Number, T2 <: Number, T3 <: Number}\n\nCompute the adjacent track angle [rad] at Equator in a ground repeating orbit measured from the satellite position. The orbit is described by its semi-major axis a [m], eccentricity [ ], inclination i [rad], and orbit cycle orbit_cyle [day].\n\nwarning: Warning\nThe code does not check if the orbit is ground-repeating with orbit_cycle [day].\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1, T2, and T3 to a float-pointing number T.\n\nExtended help\n\nA ground repeating orbit is any orbit that the number of revolutions per day is a rational number. Hence, this type of orbit repeats its ground trace after a finite number of days.\n\nThe information orbit_cyle is redundant given that we have a, e, and i. However, it is necessary to improve the algorithm precision. Otherwise, the orbit_cycle must be obtained by computing the orbit period using a, e, and i and then converting it to a rational number, leading to numerical problems.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_repeating_orbit_adjacent_track_distance-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_repeating_orbit_adjacent_track_distance","text":"ground_repeating_orbit_adjacent_track_distance(orbit_period::T1, i::T2, orbit_cycle::Integer) where {T1 <: Number, T2 <: Number} -> T\n\nCompute the adjacent track distance [m] at Equator in a ground repeating orbit.  The orbit is described by its orbital period orbit_period [s], inclination i [rad], and orbit cycle orbit_cycle [day].\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nExtended help\n\nA ground repeating orbit is any orbit that the number of revolutions per day is a rational number. Hence, this type of orbit repeats its ground trace after a finite number of days.\n\nThe information orbit_period and orbit_cyle is redundant. However, they are necessary to improve the algorithm precision. Otherwise, the orbit_cycle must be obtained by converting the floating-point number orbit_period to a rational number, leading to numerical problems.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_track-Tuple{OrbitPropagator}","page":"Library","title":"SatelliteAnalysis.ground_track","text":"ground_track(orbp::OrbitPropagator; kwargs...) -> Vector{NTuple{2, Float64}}\n\nCompute the satellite ground track using the orbit propagator orbp. It returns a vector of NTuple{2, Float64} where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the ground track.\n\nKeywords\n\nadd_nans::Bool: If true, we add NaN if there is a discontinuity in the ground track   to improve plotting.   (Default: true)\nduration::Number: Duration of the analysis.   (Default: 86400)\ninitial_time::Number: Initial time regarding the orbit propagator orbp epoch [s].   (Default: 0)\nf_eci_to_ecef::Function: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be\njulia   f_eci_to_ecef(r_i::AbstractVector, jd::Number) -> AbstractVector\nand it must return the position vector r_i represented in the ECEF at the instant jd   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (Default: _ground_track_default_eci_to_ecef)\nstep::Union{Nothing, Number}: Step for the computation. If nothing, we will roughly   compute the step to approximate 1° in the mean anomaly.   (Default: nothing)\ntrack_types::Symbol: A symbol describing what kind of track types we must add to the   output vector. It can be :ascending for only ascending passages, :descending for   only descending passages, or :all for both.   (Default: :all)\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis, UnicodePlots\n\njulia> jd₀ = date_to_jd(2024, 1, 1);\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       );\n\njulia> orbp = Propagators.init(Val(:J2), orb);\n\njulia> gt = ground_track(orbp);\n\njulia> lineplot(last.(gt), first.(gt))\n      ┌────────────────────────────────────────┐\n    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⣸⡿⠿⣻⠿⣿⠿⣟⡯⢟⡿⢿⣿⡿⣿⡟⣿⡿⢿⣿⢿⣿⢻⣿⠿⣿⡟⣿⡿⣿⡿⢿⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠞⠹⡼⠙⣶⠋⢶⠋⢣⠏⢳⡞⠀⣿⡁⡽⡇⣹⡇⢨⢏⢈⢯⠀⣿⡀⡽⡁⣹⡇⢸⣯⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢦⢰⢳⢠⢿⡀⡟⡄⡞⡇⡸⣇⢸⠁⢷⠃⣷⡇⢸⡏⠸⡼⠈⣾⠀⣷⠃⢣⠇⢹⣏⠏⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢸⡞⠘⣾⠀⣿⠁⢧⠃⢹⡇⢸⡏⠀⣼⠀⣿⡆⢰⡇⢀⣇⠀⣷⠀⣾⠀⣸⡀⢸⣿⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢀⡇⠀⣇⠀⣿⠀⢸⠀⢸⡁⢨⡇⠀⡇⡇⡏⡇⣸⢳⢸⢸⢰⢻⣀⡏⡆⡇⡇⡜⣯⠀⠀⠀⠀⠀│\n      │⠤⠤⠤⠤⢼⢧⢤⢿⠤⣿⠤⡿⡦⡼⡧⢼⣧⢴⠥⢧⡧⢼⡧⢼⡾⠼⣼⠤⣿⠤⣧⠧⢷⣧⢿⠤⠤⠤⠤⠤│\n      │⠀⠀⠀⠀⡼⢸⢸⠸⣼⠁⣇⠇⡇⡇⢳⡞⢸⢸⠀⢸⡇⢸⡇⠈⡇⠀⡏⠀⣿⠀⢸⠀⢸⢹⠘⡆⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠁⠈⡏⠀⡿⠀⢿⠀⢹⠃⢸⡇⠘⡇⠀⡜⡇⣸⡇⢸⢧⢠⢿⠀⣿⠀⡾⡄⡸⡟⠀⣷⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢆⢰⢳⢀⢿⠀⡿⡄⡼⡆⣸⣇⢰⢧⢠⠇⣧⡇⢹⡞⠸⡼⠘⣾⠁⣷⠃⢧⢧⢷⢀⡟⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢘⣎⢈⣞⠀⣿⡁⣳⡃⣹⡇⢸⣏⢘⣞⢀⡿⢆⡼⢧⣰⢳⣠⠿⣀⠾⣄⡞⣆⢈⣿⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢹⣾⣿⣾⣿⣶⣿⣧⣿⣷⣿⣷⣾⣿⣼⣿⣷⣾⣷⣾⣵⣲⣽⣶⣿⣶⣯⣶⣼⣿⣾⣿⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      └────────────────────────────────────────┘\n      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀\n\njulia> gt = ground_track(orbp, track_types = :ascending);\n\njulia> lineplot(last.(gt), first.(gt))\n      ┌────────────────────────────────────────┐\n    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢸⡛⠽⡛⠿⣟⠫⣟⠫⢍⠛⠻⢿⡻⢽⡛⡿⡛⠿⣟⠯⣟⠫⢟⠻⢿⡛⢽⡛⠽⡛⠯⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠹⡄⠘⡆⠈⢆⠈⢣⠀⢳⡀⠀⢳⡀⠹⡇⠙⡆⠈⢆⠈⢧⠀⢳⡀⠱⡀⠙⡄⠘⣆⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢦⠀⢱⠀⢸⡀⠘⡄⠈⡇⠀⣇⠀⠀⢧⠀⣷⠀⢸⠀⠸⡄⠈⡆⠀⣇⠀⢣⠀⢹⠀⠈⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢸⡀⠘⡆⠀⡇⠀⢇⠀⢹⠀⢸⠀⠀⢸⠀⡟⡆⠀⡇⠀⣇⠀⢳⠀⢸⠀⠸⡀⠈⡇⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⡇⠀⣇⠀⢳⠀⢸⠀⠸⡀⠈⡇⠀⠀⡇⡇⡇⠀⢳⠀⢸⠀⢸⡀⠈⡆⠀⡇⠀⢧⠀⠀⠀⠀⠀│\n      │⠤⠤⠤⠤⠤⢧⠤⢼⠤⢼⠤⠼⡦⠤⡧⠤⣧⠤⠤⢧⡧⢼⠤⢼⠤⠼⡤⠤⡧⠤⡧⠤⢷⠤⢼⠤⠤⠤⠤⠤│\n      │⠀⠀⠀⠀⠀⢸⠀⠸⡄⠀⡇⠀⡇⠀⢳⠀⢸⠀⠀⢸⡇⠸⡄⠈⡇⠀⡇⠀⢧⠀⢸⠀⢸⠀⠘⡆⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠈⡇⠀⡇⠀⢧⠀⢹⠀⢸⡀⠘⡆⠀⠘⡇⠀⡇⠀⢧⠀⢹⠀⢸⠀⠸⡄⠈⡇⠀⣇⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢆⠀⢳⠀⢸⠀⠸⡄⠘⡆⠀⣇⠀⢧⠀⠀⣧⠀⢹⠀⠸⡀⠘⡆⠀⣇⠀⢧⠀⢳⠀⠘⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠘⣆⠈⢆⠀⢧⡀⢳⡀⠹⡄⠘⣄⠘⣆⠀⡏⢆⠀⢧⠀⢳⡀⠹⡀⠸⣄⠘⣆⠈⢧⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠐⣬⣗⣮⣷⣦⣵⣢⣽⣲⣽⣶⣬⣗⣬⣗⣧⣬⣓⣦⣵⣢⣽⣲⣽⣶⣬⣖⣬⣗⣮⡵⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      └────────────────────────────────────────┘\n      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀\n\njulia> gt = ground_track(orbp, track_types = :descending);\n\njulia> lineplot(last.(gt), first.(gt))\n      ┌────────────────────────────────────────┐\n    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⣸⡽⠟⣻⠽⣻⠿⢛⡯⢛⡯⢟⡻⠝⣻⠝⣿⠽⢛⠯⢛⡯⢛⡿⠟⡻⠝⣻⠽⣻⠿⢓⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠞⠀⡼⠁⣰⠃⢰⠋⢠⠏⢀⡞⠀⡜⠁⡼⡇⣰⠃⢠⠏⢀⠎⠀⡞⠀⡼⠁⣰⠃⢰⣫⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⢰⠃⢠⠇⠀⡏⠀⡞⠀⡸⠀⢸⠁⢰⠃⣇⡇⠀⡏⠀⡼⠀⣸⠀⢰⠃⢠⠇⠀⣏⠇⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⡞⠀⣸⠀⢸⠁⢠⠃⠀⡇⠀⡏⠀⡼⠀⣿⠀⢰⠁⢀⡇⠀⡇⠀⡞⠀⣸⠀⢸⢸⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢀⡇⠀⡇⠀⡜⠀⢸⠀⢸⠁⢠⠇⠀⡇⠀⡏⠀⣸⠀⢸⠀⢰⠃⢀⡇⠀⡇⠀⡜⡏⠀⠀⠀⠀⠀│\n      │⠤⠤⠤⠤⢼⠤⢤⠧⠤⡧⠤⡯⠤⡼⠤⢼⠤⢴⠥⢤⡧⠤⡧⠤⡾⠤⢼⠤⢼⠤⢤⠧⠤⣧⠧⠤⠤⠤⠤⠤│\n      │⠀⠀⠀⠀⡼⠀⢸⠀⢸⠁⢀⠇⠀⡇⠀⡞⠀⢸⠀⢸⡇⢠⠃⠀⡇⠀⡏⠀⡼⠀⢸⠀⢸⢹⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠁⠀⡎⠀⡸⠀⢸⠀⢰⠃⢀⡇⠀⡇⠀⡜⡇⣸⠀⢸⠁⢠⠇⠀⡇⠀⡎⠀⡸⡞⠀⣰⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⢰⠃⢀⠇⠀⡏⠀⡼⠀⣸⠀⢰⠁⢠⠇⣇⡇⠀⡞⠀⡼⠀⢸⠁⢰⠃⢀⢧⠇⢀⡇⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢀⠎⢀⡞⠀⡼⠁⡰⠃⣠⠃⢠⠏⢀⡞⢀⡿⠀⡼⠁⣰⠃⢠⠇⢀⠎⢀⡞⠀⢀⡜⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢩⣖⣯⣔⣮⣴⣾⣥⣺⣥⣲⣥⣖⣯⣔⣯⣷⣾⣵⣺⣥⣲⣥⣶⣯⣖⣋⣤⣔⣯⣔⣎⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      └────────────────────────────────────────┘\n      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.is_ground_facility_visible-Tuple{AbstractVector, AbstractVector, Number}","page":"Library","title":"SatelliteAnalysis.is_ground_facility_visible","text":"is_ground_facility_visible(sat_r_e::AbstractVector, gf_r_e::AbstractVector, θ::Number) -> Bool\n\nCheck if the satellite with position vector sat_r_e (ECEF) is inside the visibility circle of a ground facility with position vector gf_r_e (ECEF) and a minimum elevation angle of θ [rad].\n\nNotice that sat_r_e and gf_r_e must be represented in the same ECEF frame, and must have the same unit.\n\nReturns\n\nBool: true if the satellite is inside the visibility circle, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.is_ground_facility_visible-Tuple{AbstractVector, Vararg{Number, 4}}","page":"Library","title":"SatelliteAnalysis.is_ground_facility_visible","text":"is_ground_facility_visible(sat_r_e::AbstractVector, gf_lat::Number, gf_lon::Number, gf_h::Number, θ::Number) -> Bool\n\nCheck if the satellite with position vector sat_r_e (ECEF) is inside the visibility circle of a ground facility with latitude gf_lat [rad], longitude gf_lon [rad], altitude gf_h (WGS-84), and a minimum elevation angle of θ [rad].\n\nNotice that sat_r_e and gf_h must have the same units.\n\nReturns\n\nBool: true if the satellite is inside the visibility circle, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.lighting_condition-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"SatelliteAnalysis.lighting_condition","text":"lighting_condition(r_i::AbstractVector, s_i::AbstractVector)\n\nCompute the lighting condition at the position r_i [m] considering the Sun position vector s_i [m]. The possible return values are:\n\n:sunlight: The point is under direct sunlight.\n:penumbra: The point is in penumbra region.\n:umbra: The point is in umbra region.\n\nThe algorithm used in this function was based on [1].\n\nnote: Note\nThe vectors r_i and s_i must be represented in the same reference frame.\n\nReferences\n\n[1] Longo, C. R. O., Rickman, S. L (1995). Method for the Calculation of Spacecraft   Umbra and Penumbra Shadow Terminator Points. NASA Technical Paper 3547.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.sun_sync_orbit_from_angular_velocity-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Library","title":"SatelliteAnalysis.sun_sync_orbit_from_angular_velocity","text":"sun_sync_orbit_from_angular_velocity(angvel::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, T, Bool\n\nCompute the Sun-synchronous orbit semi-major axis [m] and inclination [rad] given the angular velocity angvel [rad / s] and the orbit eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.\n\nThe algorithm here considers only the perturbation terms up to J₂.\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nmax_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 3)\nno_warnings::Bool: If true, no warnings will be printed.   (Default = false)\ntolerance::Union{Nothing, NTuple{2, Number}}: Residue tolerances to verify if the   numerical method has converged. If it is nothing, (√eps(T), √eps(T)) will be used,   where T is the internal type for the computations. Notice that the residue function   f₁ unit is [deg / day], whereas the f₂ unit is [deg / min].   (Default = 1e-18)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\nReturns\n\nT: Semi-major axis [m].\nT: Inclination [rad].\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.\n\nExtended help\n\nA Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth's orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.\n\nThe RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:\n\n∂Ω      3                       n̄\n── = - ─── R₀² . J₂ . cos(i) . ─── .\n∂t      2                       p²\n\nwhere:\n\n         ┌                                                ┐\n         │      3    R₀²                                  │\nn̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.\n         │      4     p²                                  │\n         └                                                ┘\n\nWe can express the orbit angular velocity in terms of its nodal period, i.e., the period it takes for the satellite to cross the ascending node two consecutive times:\n\n          ∂M     ∂ω\nangvel = ──── + ────,\n          ∂t     ∂t\n\n                  3    R₀²\nangvel = n̄ + n̄ . ─── . ─── . J₂ . (4 - 5sin²(i)),\n                  4     p²\n\nwhere n is the perturbed mean motion due to the same consideration as presented for the RAAN time-derivative.\n\nFinally, this function finds the pair (a, i) that simultaneously solves the equations:\n\n∂Ω\n── (a, i) = EARTH_ORBIT_MEAN_MOTION,\n∂t\n\n ∂M            ∂ω\n──── (a, i) + ──── (a, i) = angvel,\n ∂t            ∂t\n\nusing the Newton-Raphson method with the presented equations.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad)\n(7.130983932846816e6, 1.7175898375139984, true)\n\njulia> sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad, 0)\n(7.130983932846816e6, 1.7175898375139984, true)\n\njulia> sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad, 0.1)\n(7.13086251587883e6, 1.7146410689929386, true)\n\nThe user can verify some internal information of the solver by turning on the debugging logs:\n\njulia> with_logger(ConsoleLogger(stderr, Logging.Debug)) do\n           sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad)\n       end\n┌ Debug: Iteration #1\n│   Estimation :\n│     a  = 7136.635455699327 km\n│     i  = 81.57099271530629 °\n│   Residues :\n│     f₁ = 1.9706966881670205 ° / day\n│     f₂ = 0.004266929859281898 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n┌ Debug: Iteration #2\n│   Estimation :\n│     a  = 7128.856266265137 km\n│     i  = 98.46515928332974 °\n│   Residues :\n│     f₁ = -0.0073785260175135425 ° / day\n│     f₂ = -0.0016144146737784304 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n┌ Debug: Iteration #3\n│   Estimation :\n│     a  = 7130.983594940013 km\n│     i  = 98.41070350863473 °\n│   Residues :\n│     f₁ = -6.549620124363109e-6 ° / day\n│     f₂ = -2.6066638092459016e-7 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n┌ Debug: Iteration #4\n│   Estimation :\n│     a  = 7130.983932846698 km\n│     i  = 98.41064862339992 °\n│   Residues :\n│     f₁ = 8.290634845309341e-11 ° / day\n│     f₂ = -2.2648549702353193e-14 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n(7.130983932846816e6, 1.7175898375139984, true)\n\nReferences\n\n[1] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.sun_sync_orbit_inclination-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Library","title":"SatelliteAnalysis.sun_sync_orbit_inclination","text":"sun_sync_orbit_inclination(a::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, Bool\n\nCompute the inclination [rad] of the Sun-synchronous orbit with semi-major axis a [m] and the eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.\n\nThe algorithm here considers only the perturbation terms up to J₂.\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nmax_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 30)\ntolerance::Union{Nothing, Number}: Residue tolerance to verify if the numerical method   has converged. If it is nothing, √eps(T) will be used, where T is the internal   type for the computations. Notice that the residue unit is [deg / day].   (Default = nothing)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\nReturns\n\nT: Inclination [rad] of the Sun-synchronous orbit with semi-major axis a and   eccentricity e.\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.\n\nExtended help\n\nA Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth's orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.\n\nThe RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:\n\n∂Ω      3                       n̄\n── = - ─── R₀² . J₂ . cos(i) . ─── .\n∂t      2                       p²\n\nwhere:\n\n         ┌                                                ┐\n         │      3    R₀²                                  │\nn̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.\n         │      4     p²                                  │\n         └                                                ┘\n\nFinally, this function solves the equation:\n\n∂Ω\n── (i) = EARTH_ORBIT_MEAN_MOTION\n∂t\n\nfor i using the Newton-Raphson method with the presented equations.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> sun_sync_orbit_inclination(7130.982e3)\n(1.7175896973066611, true)\n\njulia> sun_sync_orbit_inclination(7130.982e3, 0)\n(1.7175896973066611, true)\n\njulia> sun_sync_orbit_inclination(7130.982e3, 0.001111)\n(1.7175893324980402, true)\n\nThe user can verify some internal information of the solver by turning on the debugging logs:\n\njulia> with_logger(ConsoleLogger(stderr, Logging.Debug)) do\n           sun_sync_orbit_inclination(7130.982e3)\n       end\n┌ Debug: Iteration #1\n│   Estimation : 98.41064059121584 °\n│   Residue    : 0.0005992085524891833 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:686\n┌ Debug: Iteration #2\n│   Estimation : 98.41064059082426 °\n│   Residue    : -4.556321986370904e-11 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:686\n(1.7175896973066611, true)\n\nReferences\n\n[1] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.sun_sync_orbit_semi_major_axis-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Library","title":"SatelliteAnalysis.sun_sync_orbit_semi_major_axis","text":"sun_sync_orbit_semi_major_axis(i::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, Bool\n\nCompute the semi-major axis [m] of the Sun-synchronous orbit with inclination i [rad] and the eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.\n\nThe algorithm here considers only the perturbation terms up to J₂.\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nmax_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 30)\ntolerance::Union{Nothing, Number}: Residue tolerance to verify if the numerical method   has converged. If it is nothing, √eps(T) will be used, where T is the internal   type for the computations. Notice that the residue unit is [deg / day].   (Default = nothing)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\nReturns\n\nT: Semi-major axis [m] of the Sun-synchronous orbit with inclination i and   eccentricity e.\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.\n\nExtended help\n\nA Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth's orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.\n\nThe RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:\n\n∂Ω      3                       n̄\n── = - ─── R₀² . J₂ . cos(i) . ─── .\n∂t      2                       p²\n\nwhere:\n\n         ┌                                                ┐\n         │      3    R₀²                                  │\nn̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.\n         │      4     p²                                  │\n         └                                                ┘\n\nFinally, this function solves the equation:\n\n∂Ω\n── (a) = EARTH_ORBIT_MEAN_MOTION\n∂t\n\nfor a using the Newton-Raphson method with the presented equations.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> sun_sync_orbit_semi_major_axis(98.410 |> deg2rad)\n(7.130827866508738e6, true)\n\njulia> sun_sync_orbit_semi_major_axis(98.410 |> deg2rad, 0)\n(7.130827866508738e6, true)\n\njulia> sun_sync_orbit_semi_major_axis(98.410 |> deg2rad, 0.001111)\n(7.1308328955274355e6, true)\n\nThe user can verify some internal information of the solver by turning on the debugging logs:\n\njulia> with_logger(ConsoleLogger(stderr, Logging.Debug)) do\n           sun_sync_orbit_semi_major_axis(98.41064163374567 |> deg2rad)\n       end\n┌ Debug: Iteration #1\n│   Estimation : 7130.981820550704 km\n│   Residue    : 0.0005989504045072862 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559\n┌ Debug: Iteration #2\n│   Estimation : 7130.982250931794 km\n│   Residue    : -2.081337784770338e-7 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559\n┌ Debug: Iteration #3\n│   Estimation : 7130.982250931845 km\n│   Residue    : -2.4312691616901194e-14 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559\n(7.130982250931845e6, true)\n\nReferences\n\n[1] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.\n\n\n\n\n\n","category":"method"},{"location":"man/beta_angle/#Beta-Angle","page":"Beta Angle","title":"Beta Angle","text":"","category":"section"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The beta angle is the angle between the orbit plane and the Sun, as shown in the following figure. The positive direction is defined as that of the orbit angular momentum.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The beta angle is useful when computing the mean amount of solar radiation a satellite receives in a particular orbit.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"<div align=\"center\">\n  <img src=\"../../assets/beta_angle.png\" alt=\"Beta Angle\" width=\"50%\"/>\n</div>","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"We can compute the beta angle of an orbit using the function:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"beta_angle(orb::KerplerianElements{Tepoch, T}, Δjd::Number; kwargs...) -> Float64","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"This function computes the beta angle [rad] for the orbit orb after Δjd days from its epoch.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The algorithm was obtained from [1].","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"note: Note\nIt is expected that the input elements are represented in the TOD reference frame. If it is not the case, they can be converted using the function orb_eci_to_eci of SatelliteToolboxTransformations.jl.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The following keywords are available:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"perturbation::Symbol: Select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J₂.\n:J4: Consider the perturbation terms J₂, J₂², and J₄.\n(Default: :J2)","category":"page"},{"location":"man/beta_angle/#Examples","page":"Beta Angle","title":"Examples","text":"","category":"section"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"We will compute the beta angle of the Amazonia-1 mission for one year. The first thing we need to do is define the orbit:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"julia> jd₀ = date_to_jd(2021, 1, 1)\n2.4592155e6\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45922e6 (2021-01-01T00:00:00)\n Semi-major axis : 7130.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   78.4021   °\n Arg. of Perigee :   90.0      °\n    True Anomaly :    0.0      °","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"Now, we can use the function beta_angle to obtain the beta angle [rad] for each day of the year:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"julia> β = beta_angle.(orb, 1:365)\n365-element Vector{Float64}:\n 0.432769059439428\n 0.43467611908719883\n 0.43656171032862834\n 0.43842380844466566\n ⋮\n 0.4283190235472065\n 0.43029475458852695\n 0.43225862572658325\n 0.4342085608107653","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"If we use CairoMakie.jl to plot, we obtain:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"<div align=\"center\">\n  <img src=\"../../assets/beta_angle_amz1.png\" alt=\"Beta Angle of the Amazonia-1 Mission\" width=\"100%\"/>\n</div>","category":"page"},{"location":"man/beta_angle/#References","page":"Beta Angle","title":"References","text":"","category":"section"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"[1]: Mortari, D., Wilkins, M. P., and Bruccoleri, C.  On Sun-Synchronous Orbits and Associated Constellations","category":"page"},{"location":"man/eclipse_time/#Eclipse-Time","page":"Eclipse Time","title":"Eclipse Time","text":"","category":"section"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The eclipse time is the period the satellite does not receive sunlight due to the Earth shadow. This information is paramount for mission design since it directly interferes in the power and thermal subsystems.","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"We can compute the eclipse time of a satellite using the function:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"eclipse_time_summary(orbp::OrbitPropagator; kwargs...) -> DataFrame","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"This function computes the eclipse time summary for the orbit propagator orbp. The summary is computed as the total time the object stays in the sunlight, penumbra, and umbra regions per orbit at each day. The algorithm was adapted from [1].","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The following keywords are available:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"num_days::Number: Number of days in which the analysis will be performed. (Default = 365)\nstep::Number: The step in which the propagation will occur. Notice that this function has a crossing estimation to accurately estimate the transition between the regions. However, if this step is very large, we may miss some small regions. If it is negative, it will be selected as the time in which the mean anomaly advances 0.5°. (Default = -1)\nunit::Symbol: Select the unit in which the results will be generated. The possible values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The function returns a DataFrame with three columns:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"sunlight: Total sunlight time per orbit at each day [unit].\npenumbra: Total penumbra time per orbit at each day [unit].\numbra: Total umbra time per orbit at each day [unit].","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The unit of each column is stored in the DataFrame using metadata.","category":"page"},{"location":"man/eclipse_time/#Examples","page":"Eclipse Time","title":"Examples","text":"","category":"section"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"We will compute the eclipse time of the Amazonia-1 mission for one year. The first thing we need to do is define the orbit:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"julia> jd₀ = date_to_jd(2021, 1, 1)\n2.4592155e6\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45922e6 (2021-01-01T00:00:00)\n Semi-major axis : 7130.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :   78.4021   °\n Arg. of Perigee :   90.0      °\n    True Anomaly :    0.0      °","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The next step is to define the desired propagator:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"julia> orbp = Propagators.init(Val(:J2), orb)\nOrbitPropagatorJ2{Float64, Float64}:\n   Propagator name : J2 Orbit Propagator\n  Propagator epoch : 2021-01-01T00:00:00\n  Last propagation : 2021-01-01T00:00:00","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"Now, we can use the function eclipse_time_summary to obtain the eclipse time information for each day of the year:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"julia> df = eclipse_time_summary(orbp; unit = :m)\n365×4 DataFrame\n Row │ date        sunlight  penumbra  umbra\n     │ Date        Float64   Float64   Float64\n─────┼─────────────────────────────────────────\n   1 │ 2021-01-01   66.2105  0.340195  33.4493\n   2 │ 2021-01-02   66.2308  0.340627  33.4285\n   3 │ 2021-01-03   66.2461  0.340958  33.4129\n   4 │ 2021-01-04   66.2623  0.341263  33.3964\n  ⋮  │     ⋮          ⋮         ⋮         ⋮\n 362 │ 2021-12-28   66.18    0.339203  33.4808\n 363 │ 2021-12-29   66.1956  0.33955   33.4648\n 364 │ 2021-12-30   66.2122  0.339889  33.4479\n 365 │ 2021-12-31   66.2327  0.340339  33.4269\n                               357 rows omitted","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"Finally, we can use the DataFrame to analyze the result. For example, the maximum eclipse time in an orbit is:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"julia> maximum(df.penumbra .+ df.umbra)\n34.66395872764383","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"i.e., 34.66 minutes.","category":"page"},{"location":"man/eclipse_time/#References","page":"Eclipse Time","title":"References","text":"","category":"section"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"[1] Longo, C. R. O., Rickman, S. L (1995). Method for the Calculation of Spacecraft Umbra and Penumbra Shadow Terminator Points. NASA Technical Paper 3547.","category":"page"},{"location":"#SatelliteAnalysis.jl","page":"Home","title":"SatelliteAnalysis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SatelliteAnalysis\nDocTestSetup = quote\n    using SatelliteAnalysis\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains several functions to perform analysis related to satellites. Those functions were split from the package SatelliteToolbox.jl.","category":"page"},{"location":"#Instalation","page":"Home","title":"Instalation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"SatelliteAnalysis\")","category":"page"}]
}
