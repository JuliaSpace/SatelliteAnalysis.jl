var documenterSearchIndex = {"docs":
[{"location":"man/ground_facilities/ground_facility_accesses/#Ground-Facilities-Accesses","page":"Ground Facility Accesses","title":"Ground Facilities Accesses","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"using SatelliteAnalysis","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"We can use the function:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"ground_facility_accesses(orbp, [(WGS84)]; kwargs...) -> DataFrame","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"to compute the accesses of a satellite with orbit propagator orbp (see Propagators.init) to the ground facilities defined in the vector [(WGS84)]. The analysis interval begins in the propagator epoch plus initial_time and lasts for duration [s], where both are keywords.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"The ground facilities are specified using a vector of tuples with three numbers:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"Tuple{T1, T2, T3} where {T1 <: Number, T2 <: Number, T3 <: Number}","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"containing the WGS84 position of each ground facility [(WGS84)]:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"(latitude [rad], longitude [rad], altitude [m])","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"Those geodetic information are transformed to an ECEF vector using the function geodetic_to_ecef.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"The following keywords are available:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"duration::Number: Duration of the analysis [s].   (Default = 86400)\nf_eci_to_ecef::Function: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be\nf_eci_to_ecef(r_i::AbstractVector, jd::Number) -> AbstractVector\nand it must return the position vector r_i represented in the ECEF at the instant jd   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (Default: _ground_facility_default_eci_to_ecef)\ninitial_time::Number: Initial time of the analysis after the propagator epoch [s].   (Default = 0)\nminimum_elevation::Number: Minimum elevation angle for communication between the   satellite and the ground facilities [rad].   (Default = 10°)\nreduction::Function: A function that receives a boolean vector with the visibility   between the satellite and each ground facility. It must return a boolean value   indicating if the access must be computed or not. This is useful to merge access time   between two or more facilities.   (Default = v -> |(v...) i.e. compute the access if at least one ground   facilities is visible)\nstep::Number: The step [s] used to propagate the orbit. Notice that we perform a cross   tuning to accurately obtain the access time. However, if an access is lower than the   step, it can be neglected.   (Default = 60)\nunit::Symbol: Select the unit in which the duration will be computed. The possible   values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"This function returns a DataFrame with three columns:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"access_beginning: Time of the access beginning [UTC] encoded using DateTime.\naccess_end: Time of the access end [UTC] encoded using DateTime.\nduration: Duration of the access [s]. The unit of the column duration is stored in the DataFrame using metadata.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/#Examples","page":"Ground Facility Accesses","title":"Examples","text":"","category":"section"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"Let's compute the access time of the Amazonia-1 satellite to the INPE's ground station at Cuiabá, MT, Brazil.","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"First, we need to define an orbit propagator. In this case, we will use the TLE obtained from CelesTrak when this documentation was written:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"tle_amz1 = tle\"\"\"\n    AMAZONIA 1\n    1 47699U 21015A   24008.13079366  .00000299  00000+0  10693-3 0  9994\n    2 47699  98.4120  87.2350 0001570  92.1147 268.0222 14.40836963150331\n    \"\"\"\n\norbp = Propagators.init(Val(:SGP4), tle_amz1)","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"Now, we can compute the access time during one day considering the INPE's station at Cuiabá:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"ground_facility_accesses(\n    orbp,\n    [(-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)];\n    duration = 1 * 86400,\n    minimum_elevation = 5 |> deg2rad,\n    unit = :m\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"If we want to change the reference frames used in the analysis, we must provide a function f_eci_to_ecef(r_i, jd) that converts the vector r_i to the desired ECEF frame at the instant jd [Julian Day]. For repl, let's use the more precise ITRF instead of the PEF (default):","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"const eop = fetch_iers_eop(Val(:IAU1980));\n\nfunction f_eci_to_ecef(r_teme, jd)\n    D_itrf_teme = r_eci_to_ecef(TEME(), ITRF(), jd, eop)\n    r_itrf = D_itrf_teme * r_teme\n    return r_itrf\nend\n\nground_facility_accesses(\n    orbp,\n    [(-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)];\n    duration = 1 * 86400,\n    f_eci_to_ecef = f_eci_to_ecef,\n    minimum_elevation = 5 |> deg2rad,\n    unit = :m\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"We can also perform analyses using multiple ground facilities. For repl, let's find the accumulated access if we consider the INPE's stations at Cuiabá, MT, Brazil, and Alcântara, MA, Brazil:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"ground_facility_accesses(\n    orbp,\n    [\n        (-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)\n        (-( 2 + 20 / 60) |> deg2rad, -(44 + 24 / 60) |> deg2rad, 0)\n    ];\n    duration = 1 * 86400,\n    minimum_elevation = 5 |> deg2rad,\n    unit = :m\n)","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"By default, the algorithm computes the accumulated access, i.e., it considers the access active if either station has visibility to the satellite. We can change this logic by overloading the function in the keyword parameter reduction. For repl, let's compute only the accesses when the satellite has visibility to both ground stations at the same time:","category":"page"},{"location":"man/ground_facilities/ground_facility_accesses/","page":"Ground Facility Accesses","title":"Ground Facility Accesses","text":"ground_facility_accesses(\n    orbp,\n    [\n        (-(15 + 33 / 60) |> deg2rad, -(56 + 04 / 60) |> deg2rad, 0)\n        (-( 2 + 20 / 60) |> deg2rad, -(44 + 24 / 60) |> deg2rad, 0)\n    ];\n    duration = 1 * 86400,\n    minimum_elevation = 5 |> deg2rad,\n    reduction = v -> (&)(v...),\n    unit = :m\n)","category":"page"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/","page":"Library","title":"Library","text":"Documentation for SatelliteAnalysis.jl.","category":"page"},{"location":"lib/library/","page":"Library","title":"Library","text":"Modules = [SatelliteAnalysis]","category":"page"},{"location":"lib/library/#SatelliteAnalysis._F_and_∂F_l0p-Tuple{Integer, Integer, Number}","page":"Library","title":"SatelliteAnalysis._F_and_∂F_l0p","text":"_F_and_∂F_l0p(l::Integer, p::Integer, i::Number) -> BigFloat, BigFloat\n\nCompute the inclination function F_{l,0,p}(i) and its derivative ∂F_{l,0,p} / ∂ias defined in [1, p. 642].\n\nnote: Note\nInternally, we must use BigFloat to allow calculations on high degrees.\n\nReferences\n\n[1] Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications. 4th ed.   Microcosm Press, Hawthorne, CA.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.beta_angle-Tuple{KeplerianElements, Number}","page":"Library","title":"SatelliteAnalysis.beta_angle","text":"beta_angle(orb::KerplerianElements{Tepoch, T}, Δjd::Number; kwargs...) -> Float64\n\nCompute the beta angle [rad] for the orbit orb after Δjd days from its epoch.\n\nThe algorithm was obtained from [1].\n\nnote: Note\nIt is expected that the input elements are represented in the TOD reference frame. If it is not the case, they can be converted using the function orb_eci_to_eci of SatelliteToolboxTransformations.jl.\n\nKeywords\n\nperturbation::Symbol: Select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J₂.\n:J4: Consider the perturbation terms J₂, J₂², and J₄.\n(Default: :J2)\n\nReferences\n\n[1]: Mortari, D., Wilkins, M. P., and Bruccoleri, C.  On Sun-Synchronous Orbits and   Associated Constellations\n\nExtended Help\n\nThe beta angle is the angle between the orbit plane and the Sun. The positive direction is defined as that of the orbit angular momentum.\n\nThe beta angle is useful when computing the mean amount of solar radiation a satellite receives in a particular orbit.\n\nExamples\n\njulia> using SatelliteAnalysis, UnicodePlots\n\njulia> jd₀ = date_to_jd(2021, 1, 1, 0, 0, 0)\n\njulia> orb = KeplerianElements(\n            jd₀,\n            7130.982e3,\n            0.001111,\n            98.405 |> deg2rad,\n            ltdn_to_raan(10.5, jd₀),\n            90     |> deg2rad,\n            0\n        )\n\njulia> β = beta_angle.(orb, 0:1:364)\n\njulia> lineplot(0:1:364, rad2deg.(β), xlabel = \"Day\", ylabel = \"Beta angle [°]\")\n                     ┌────────────────────────────────────────┐\n                  30 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⣠⠞⠉⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⡴⠁⠀⠀⠀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠃⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠁⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⠀⠀⠀⠀⠀⠀⣠⠞⠀⠀⠀⠀⠀⠀│\n   Beta angle [°]    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠖⠋⠀⠀⠀⠉⠓⠲⠤⠴⠚⠁⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣄⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠦⣄⣀⡠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                  10 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n                     └────────────────────────────────────────┘\n                     ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀400⠀\n                     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Day⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.design_sun_sync_ground_repeating_orbit-Tuple{Int64, Int64}","page":"Library","title":"SatelliteAnalysis.design_sun_sync_ground_repeating_orbit","text":"design_sun_sync_ground_repeating_orbit(minimum_repetition::Int, maximum_repetition::Int; kwargs...) -> DataFrame\n\nList all the Sun synchronous, ground repeating orbits in which their repetition period is in the interval [minimum_repetition, maximum_repetition] days.\n\nThis function returns a DataFrame with the following columns:\n\nsemi_major_axis: Orbit semi-major axis.\naltitude: Orbit altitude above the Equator (a - R0).\ninclination: Orbit inclination.\nperiod: Orbital period.\nrev_per_days: If the keyword pretify_rev_per_days is false, this column contains   Tuples with the integer and rational parts of the number of revolutions per day.   Otherwise, it contains a string with a prety representation of the number of revolutions   per day.\nadjacent_gt_distance: Distance between two adjacent ground tracks at Equator.\nadjacent_gt_angle: Angle between two adjacent ground tracks at Equator measured from the   satellite position.\n\nnote: Note\nThe units of those columns depends on the keywords.\n\nKeywords\n\nangle_unit::Symbol: Unit for all the angles in the output DataFrame.  It can be :deg   for degrees or :rad for radians.   (Default: :deg)\ndistance_unit::Symbol: The unit for all the distances in the output DataFrame. It can   be :m for meters or :km for kilometers.   (Default: :km)\neccentricity::Number: Orbit eccentricity.   (Default: 0)\nint_rev_per_day::Tuple: Tuple with the integer parts of the number of revolutions per   day to be analyzed.   (Default = (13, 14, 15, 16, 17))\npretity_rev_per_days::Bool: If true, the column with the revolutions per day will be   conveted to a string with a pretty representation of this information.   (Default: true)\nmaximum_altitude::Union{Nothing, Number}: Maximum altitude [m] of the orbits in the   output DataFrame. If it is nothing, the algorithm will not apply a higher limit to   the orbital altitude.   (Default = nothing)\nminimum_altitude::Union{Nothing, Number}: Minimum altitude [m] of the orbits in the   output DataFrame. If it is nothing, the algorithm will not apply a lower limit to   the orbital altitude.   (Default = nothing)\ntime_unit::Symbol: Unit for all the time values in the output DataFrame.  It can be   :s for seconds, :m for minutes, or :h for hours.   (Default = :h)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.eclipse_time_summary-Tuple{OrbitPropagator}","page":"Library","title":"SatelliteAnalysis.eclipse_time_summary","text":"eclipse_time_summary(orbp::OrbitPropagator; kwargs...) -> DataFrame\n\nCompute the eclipse time summary for the orbit propagator orbp. The summary is computed as the total time the object stays in the sunlight, penumbra, and umbra regions per orbit at each day.\n\nKeywords\n\nnum_days::Number: Number of days in which the analysis will be performed.   (Default = 365)\nstep::Number: The step in which the propagation will occur. Notice that this function   has a crossing estimation to accurately estimate the transition between the regions.   However, if this step is very large, we may miss some small regions. If it is negative,   it will be selected as the time in which the mean anomaly advances 0.5°.   (Default = -1)\nunit::Symbol: Select the unit in which the results will be generated. The possible   values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.\n\nReturns\n\nDataFrame: The function returns a DataFrame with three columns:\nsunlight: Total sunlight time per orbit at each day [unit].\npenumbra: Total penumbra time per orbit at each day [unit].\numbra: Total umbra time per orbit at each day [unit].\nThe unit of each column is stored in the DataFrame using metadata.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> orb = KeplerianElements(\n           date_to_jd(2021, 1, 1, 0, 0, 0),\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           90     |> deg2rad,\n           0\n       )\n\njulia> orbp = Propagators.init(Val(:J2), orb)\n\njulia> df = eclipse_time_summary(orbp; num_days = 5)\n5×4 DataFrame\n Row │ date        sunlight  penumbra  umbra\n     │ Date        Float64   Float64   Float64\n─────┼─────────────────────────────────────────\n   1 │ 2021-01-01   3972.63   20.4117  2006.96\n   2 │ 2021-01-02   3973.85   20.4376  2005.71\n   3 │ 2021-01-03   3974.77   20.4575  2004.77\n   4 │ 2021-01-04   3975.74   20.4758  2003.79\n   5 │ 2021-01-05   3976.94   20.5022  2002.55\n\njulia> df = eclipse_time_summary(orbp; num_days = 5, unit = :m)\n5×4 DataFrame\n Row │ date        sunlight  penumbra  umbra\n     │ Date        Float64   Float64   Float64\n─────┼─────────────────────────────────────────\n   1 │ 2021-01-01   66.2105  0.340195  33.4493\n   2 │ 2021-01-02   66.2308  0.340627  33.4285\n   3 │ 2021-01-03   66.2461  0.340958  33.4129\n   4 │ 2021-01-04   66.2623  0.341263  33.3964\n   5 │ 2021-01-05   66.2824  0.341704  33.3759\n\njulia> colmetadata(df)\nDict{Symbol, Dict{String, Symbol}} with 3 entries:\n  :penumbra => Dict(\"Unit\"=>:m)\n  :sunlight => Dict(\"Unit\"=>:m)\n  :umbra    => Dict(\"Unit\"=>:m)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.find_crossing-Union{Tuple{N}, Tuple{Function, Number, Number, Any, Any, Vararg{Any, N}}} where N","page":"Library","title":"SatelliteAnalysis.find_crossing","text":"find_crossing(f::Function, t₀::Number, t₁::Number, s₀, s₁, vargs...; Δ = 1e-3, max = 100, kwargs...) -> T\n\nReturn the crossing time tc in which the function f(t) goes from the state s₀ to the state s₁. It is assumed that f(t₀) = s₀ and f(t₁) = s₁.\n\nThe parameters in vargs... are passed to the function f after t, and the keywords kwargs... are also passed to f. Hence, it will always be called as f(t, vargs...; kwargs...).\n\nIf the computed interval is smaller than Δ, or if the number of iterations is higher than max, the algorithm stops.\n\nnote: Note\nThe output type T is obtained by the type of (t₁ + t₂) / 2.\n\nExamples\n\njulia> SatelliteAnalysis.find_crossing(\n    t -> (sin(t) > 0),\n    -0.3,\n    0.3,\n    false,\n    true;\n    Δ = 1e-10\n)\n6.984919309616089e-11\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.frozen_orbit-Tuple{Number, Number}","page":"Library","title":"SatelliteAnalysis.frozen_orbit","text":"frozen_orbit(a::Number, i::Number; kwargs...) -> Float64, Float64\n\nCompute the eccentricity [ ] and argument of perigee [rad] to obtain a frozen orbit when the orbit has semi-major axis a [m] and inclination i [rad]. This function uses the theory in [1].\n\nnote: Note\nThis function uses BigFloat internally to perform all computations, allowing very high degrees. However, the user must ensure that the default precision is enough for the required degree. Refer to the function setprecision for more information.\n\nKeywords\n\ngravity_model::Union{Nothing, AbstractGravityModel}: Gravity model used to compute the   frozen eccentricity. Refer to the object AbstractGravityModel of the package   SatelliteToolboxGravityModels.jl for more information. If it is nothing, the system   will automatically fetch and load the EGM96 gravity model. However, loading a gravity   model can significantly decrease the performance. Thus, it is advisable to pass a   gravity model here.   (Default = nothing)\nmax_degree: Maximum gravity model degree used to compute the frozen eccentricity. If it   is equal to or lower than 0, the maximum degree in grav_model will be used. Otherwise,   if it is lower than 3 or higher than the grav_model maximum degree, it will be clamped   accordingly.   (Default = 53)\n\nReferences\n\n[1] Rosborough, G. W.; Ocampo, C. A (1991). Influence of higher degree zonals on the   frozen orbit geometry. Proceedings of the AAS/AIAA Astrodynamics Conference, Durango,   CO.\n\nExtended Help\n\nDue to the Earth's gravitational perturbation, the orbit of a salite will experience secular changes in the argument of perigee. Hence, the satellite mean altitude per latitude will differ during the mission. This effect can be problematic, especially if we must compare images by a camera onboard the satellite in different periods. The altitude variation will change the resolution, leading to some problems when comparing the data.\n\nWe can avoid this problem if we compute an eccentricity and the argument of perigee that yields theoretically:\n\nde      dω\n── = 0, ── = 0\ndt      dt\n\nThis orbit is called frozen. Refer to [1] for more information.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> frozen_orbit(7130.982e3, 98.410 |> deg2rad)\n(0.0011641853028456078, 1.5707963267948966)\n\njulia> jgm3 = GravityModels.load(IcgemFile, fetch_icgem_file(:JGM3))\n[ Info: Downloading the ICGEM file 'JGM3.gfc' from 'http://icgem.gfz-potsdam.de/getmodel/gfc/a3375e01a717ac162962138a5e94f10\n466b71aa4a130d7f7d5b18ab3d5f90c3d/JGM3.gfc'...\nIcgemFile{Float64}:\n      Product type : gravity_field\n       Model name  : JGM3\n  Gravity constant : 3.986004415e14\n            Radius : 6.3781363e6\n    Maximum degree : 70\n            Errors : formal\n       Tide system : unknown\n              Norm : fully_normalized\n         Data type : Float64\n\njulia> frozen_orbit(7130.982e3, 98.410 |> deg2rad; gravity_model = jgm3)\n(0.001163484769069545, 1.5707963267948966)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_facility_accesses-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_facility_accesses","text":"ground_facility_accesses(orbp, [(WGS84)]; kwargs...) -> DataFrame\n\nCompute the accesses of a satellite with orbit propagator orbp (see Propagators.init) to the ground facilities defined in the vector [(WGS84)]. The analysis interval begins in the propagator epoch plus initial_time and lasts for duration [s], where both are keywords.\n\nThe ground facilities are specified using a vector of tuples with three numbers:\n\nTuple{T1, T2, T3} where {T1 <: Number, T2 <: Number, T3 <: Number}\n\ncontaining the WGS84 position of each ground facility [(WGS84)]:\n\n(latitude [rad], longitude [rad], altitude [m])\n\nThose geodetic information are transformed to an ECEF vector using the function geodetic_to_ecef.\n\nKeywords\n\nduration::Number: Duration of the analysis [s].   (Default = 86400)\nf_eci_to_ecef::Function: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be\njulia   f_eci_to_ecef(r_i::AbstractVector, jd::Number) -> AbstractVector\nand it must return the position vector r_i represented in the ECEF at the instant jd   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (Default: _ground_facility_default_eci_to_ecef)\ninitial_time::Number: Initial time of the analysis after the propagator epoch [s].   (Default = 0)\nminimum_elevation::Number: Minimum elevation angle for communication between the   satellite and the ground facilities [rad].   (Default = 10°)\nreduction::Function: A function that receives a boolean vector with the visibility   between the satellite and each ground facility. It must return a boolean value   indicating if the access must be computed or not. This is useful to merge access time   between two or more facilities.   (Default = v -> |(v...) i.e. compute the access if at least one ground   facilities is visible)\nstep::Number: The step [s] used to propagate the orbit. Notice that we perform a cross   tuning to accurately obtain the access time. However, if an access is lower than the   step, it can be neglected.   (Default = 60)\nunit::Symbol: Select the unit in which the duration will be computed. The possible   values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.\n\nReturns\n\nDataFrame: The function returns a DataFrame with three columns:\naccess_beginning: Time of the access beginning [UTC] encoded using DateTime.\naccess_end: Time of the access end [UTC] encoded using DateTime.\nduration: Duration of the access [s].\nThe unit of the column duration is stored in the DataFrame using metadata.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> jd₀ = date_to_jd(2024, 1, 1);\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       );\n\njulia> orbp = Propagators.init(Val(:J2), orb);\n\njulia> ground_facility_accesses(orbp, (0, 0, 0))\n2×3 DataFrame\n Row │ access_beginning         access_end               duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T10:20:03.136  2024-01-01T10:30:02.971   599.835\n   2 │ 2024-01-01T22:49:55.910  2024-01-01T22:59:23.470   567.56\n\njulia> ground_facility_accesses(orbp, (0, 0, 0); unit = :m)\n2×3 DataFrame\n Row │ access_beginning         access_end               duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T10:20:03.136  2024-01-01T10:30:02.971   9.99725\n   2 │ 2024-01-01T22:49:55.910  2024-01-01T22:59:23.470   9.45933\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_facility_gaps-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{OrbitPropagator, Tuple{T1, T2, T3}}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_facility_gaps","text":"ground_facility_gaps(orbp, args...; duration::Number = 86400, initial_time::Number = 0, kwargs...) -> DataFrame\n\nCompute the gaps between the accesses of ground facilities. The arguments and keywords are the same as the ones used in the function ground_facility_accesses.\n\nNotice that the gap analysis starts in the orbit propagator epoch plus initial_time and lasts for duration [s].\n\nReturns\n\nDataFrame: The function returns a DataFrame with three columns:\ngap_beginning: Time of the access beginning [UTC] encoded using DateTime.\ngap_end: Time of the access end [UTC] encoded using DateTime.\nduration: Duration of the access [s].\nThe unit of the column duration is stored in the DataFrame using metadata.\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> jd₀ = date_to_jd(2024, 1, 1);\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       );\n\njulia> orbp = Propagators.init(Val(:J2), orb);\n\njulia> ground_facility_gaps(orbp, (0, 0, 0))\n3×3 DataFrame\n Row │ gap_beginning            gap_end                  duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T00:00:00      2024-01-01T10:20:03.136  37203.1\n   2 │ 2024-01-01T10:30:02.971  2024-01-01T22:49:55.910  44392.9\n   3 │ 2024-01-01T22:59:23.470  2024-01-02T00:00:00       3636.53\n\njulia> ground_facility_gaps(orbp, (0, 0, 0); unit = :m)\n3×3 DataFrame\n Row │ gap_beginning            gap_end                  duration \n     │ DateTime                 DateTime                 Float64  \n─────┼────────────────────────────────────────────────────────────\n   1 │ 2024-01-01T00:00:00      2024-01-01T10:20:03.136  620.052\n   2 │ 2024-01-01T10:30:02.971  2024-01-01T22:49:55.910  739.882\n   3 │ 2024-01-01T22:59:23.470  2024-01-02T00:00:00       60.6088\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_facility_visibility_circle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Tuple{T1, T2, T3}, Number}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_facility_visibility_circle","text":"ground_facility_visibility_circle(gf_wgs84::Tuple, satellite_position_norm::Number; kwargs...) -> Vector{NTuple{2, Float64}}\n\nCompute the ground facility visibility circle from the position gf_wgs84 (WGS84) to a satellite in which its distance from the Earth's center is satellite_position_norm [m]. It returns a vector of NTuple{2, Float64} where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the visibility circle.\n\nThe ground facility is specified using a tuple with its WGS84 position:\n\n(latitude [rad], longitude [rad], altitude [m])\n\nKeywords\n\nazimuth_step::Number: The step in the azimuth used to compute the visibility circle.   (Default: 0.1 |> deg2rad)\nminimum_elevation::Number: Minimum elevation angle for communication between the   satellite and the ground facility [rad].   (Default: 10 |> deg2rad)\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis, UnicodePlots\n\njulia> gfv = ground_facility_visibility_circle((0, 0, 0), EARTH_EQUATORIAL_RADIUS + 700e3);\n\njulia> lineplot(last.(gfv) .|> rad2deg, first.(gfv) .|> rad2deg; xlim = (-180, 180), ylim = (-90, 90))\n       ┌────────────────────────────────────────┐ \n    90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠚⠉⡏⠓⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠀⠀⠀⡇⠀⠀⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⡇⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢼⠤⠤⠤⠤⡧⠤⠤⠤⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⡇⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⡇⠀⠀⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⢤⣀⣇⡤⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   -90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       └────────────────────────────────────────┘ \n       ⠀-180⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀180⠀ \n\njulia> gfv = ground_facility_visibility_circle((-40 |> deg2rad, -60 |> deg2rad, 700), EARTH_EQUATORIAL_RADIUS + 700e3);\n\njulia> lineplot(last.(gfv) .|> rad2deg, first.(gfv) .|> rad2deg; xlim = (-180, 180), ylim = (-90, 90))\n       ┌────────────────────────────────────────┐ \n    90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤⡤⠤⠶⠤⣤⠤⠤⠤⠤⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠋⠀⠀⠀⠀⠈⠳⣄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠘⣆⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       │⠀⠀⠀⠀⠀⠀⠀⠳⢤⣀⠀⠀⠀⠀⠀⠀⢀⣀⡴⠃⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   -90 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠉⠉⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n       └────────────────────────────────────────┘ \n       ⠀-180⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀180⠀ \n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_repeating_orbit_adjacent_track_angle-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_repeating_orbit_adjacent_track_angle","text":"ground_repeating_orbit_adjacent_track_angle(a::T1, e::T2, i::T3, orbit_cycle::Integer; kwargs...) where {T1 <: Number, T2 <: Number, T3 <: Number}\n\nCompute the adjacent track angle [rad] at Equator in a ground repeating orbit measured from the satellite position. The orbit is described by its semi-major axis a [m], eccentricity [ ], inclination i [rad], and orbit cycle orbit_cyle [day].\n\nwarning: Warning\nThe code does not check if the orbit is ground-repeating with orbit_cycle [day].\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1, T2, and T3 to a float-pointing number T.\n\nKeywords\n\nperturbation::Symbol: Symbol to select the perturbation terms that will be used. It can   be :J0, :J2, or :J4.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default: GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default: EGM_2008_J2)\nJ4::Number: J₄ perturbation term.   (Default: EGM_2008_J4)\nR0::Number: Earth's equatorial radius [m].   (Default: EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)\n\nExtended help\n\nA ground repeating orbit is any orbit that the number of revolutions per day is a rational number. Hence, this type of orbit repeats its ground trace after a finite number of days.\n\nThe information orbit_cyle is redundant given that we have a, e, and i. However, it is necessary to improve the algorithm precision. Otherwise, the orbit_cycle must be obtained by computing the orbit period using a, e, and i and then converting it to a rational number, leading to numerical problems.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_repeating_orbit_adjacent_track_distance-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, Integer}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_repeating_orbit_adjacent_track_distance","text":"ground_repeating_orbit_adjacent_track_distance(orbit_period::T1, i::T2, orbit_cycle::Integer; kwargs...) where {T1 <: Number, T2 <: Number} -> T\n\nCompute the adjacent track distance [m] at Equator in a ground repeating orbit.  The orbit is described by its orbital period orbit_period [s], inclination i [rad], and orbit cycle orbit_cycle [day].\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nperturbation::Symbol: Symbol to select the perturbation terms that will be used. It can   be :J0, :J2, or :J4.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default: GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default: EGM_2008_J2)\nJ4::Number: J₄ perturbation term.   (Default: EGM_2008_J4)\nR0::Number: Earth's equatorial radius [m].   (Default: EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)\n\nExtended help\n\nA ground repeating orbit is any orbit that the number of revolutions per day is a rational number. Hence, this type of orbit repeats its ground trace after a finite number of days.\n\nThe information orbit_period and orbit_cyle is redundant. However, they are necessary to improve the algorithm precision. Otherwise, the orbit_cycle must be obtained by converting the floating-point number orbit_period to a rational number, leading to numerical problems.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_track-Tuple{OrbitPropagator}","page":"Library","title":"SatelliteAnalysis.ground_track","text":"ground_track(orbp::OrbitPropagator; kwargs...) -> Vector{NTuple{2, Float64}}\n\nCompute the satellite ground track using the orbit propagator orbp. It returns a vector of NTuple{2, Float64} where the first element is the latitude [rad] and the second is the longitude [rad] of each point in the ground track.\n\nKeywords\n\nadd_nans::Bool: If true, we add NaN if there is a discontinuity in the ground track   to improve plotting.   (Default: true)\nduration::Number: Duration of the analysis.   (Default: 86400)\ninitial_time::Number: Initial time regarding the orbit propagator orbp epoch [s].   (Default: 0)\nf_eci_to_ecef::Function: Function to convert the orbit propagator position represented   in the Earth-centered inertial (ECI) reference frame to the Earth-centered, Earth-fixed   (ECEF) reference frame. The signature must be\njulia   f_eci_to_ecef(r_i::AbstractVector, jd::Number) -> AbstractVector\nand it must return the position vector r_i represented in the ECEF at the instant jd   [Julian Day]. By default, we use TEME as the ECI and PEF as the ECEF.   (Default: _ground_track_default_eci_to_ecef)\nstep::Union{Nothing, Number}: Step for the computation. If nothing, we will roughly   compute the step to approximate 1° in the mean anomaly.   (Default: nothing)\ntrack_types::Symbol: A symbol describing what kind of track types we must add to the   output vector. It can be :ascending for only ascending passages, :descending for   only descending passages, or :all for both.   (Default: :all)\n\nExtended Help\n\nExamples\n\njulia> using SatelliteAnalysis, UnicodePlots\n\njulia> jd₀ = date_to_jd(2024, 1, 1);\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.405 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       );\n\njulia> orbp = Propagators.init(Val(:J2), orb);\n\njulia> gt = ground_track(orbp);\n\njulia> lineplot(last.(gt), first.(gt))\n      ┌────────────────────────────────────────┐\n    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⣸⡿⠿⣻⠿⣿⠿⣟⡯⢟⡿⢿⣿⡿⣿⡟⣿⡿⢿⣿⢿⣿⢻⣿⠿⣿⡟⣿⡿⣿⡿⢿⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠞⠹⡼⠙⣶⠋⢶⠋⢣⠏⢳⡞⠀⣿⡁⡽⡇⣹⡇⢨⢏⢈⢯⠀⣿⡀⡽⡁⣹⡇⢸⣯⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢦⢰⢳⢠⢿⡀⡟⡄⡞⡇⡸⣇⢸⠁⢷⠃⣷⡇⢸⡏⠸⡼⠈⣾⠀⣷⠃⢣⠇⢹⣏⠏⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢸⡞⠘⣾⠀⣿⠁⢧⠃⢹⡇⢸⡏⠀⣼⠀⣿⡆⢰⡇⢀⣇⠀⣷⠀⣾⠀⣸⡀⢸⣿⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢀⡇⠀⣇⠀⣿⠀⢸⠀⢸⡁⢨⡇⠀⡇⡇⡏⡇⣸⢳⢸⢸⢰⢻⣀⡏⡆⡇⡇⡜⣯⠀⠀⠀⠀⠀│\n      │⠤⠤⠤⠤⢼⢧⢤⢿⠤⣿⠤⡿⡦⡼⡧⢼⣧⢴⠥⢧⡧⢼⡧⢼⡾⠼⣼⠤⣿⠤⣧⠧⢷⣧⢿⠤⠤⠤⠤⠤│\n      │⠀⠀⠀⠀⡼⢸⢸⠸⣼⠁⣇⠇⡇⡇⢳⡞⢸⢸⠀⢸⡇⢸⡇⠈⡇⠀⡏⠀⣿⠀⢸⠀⢸⢹⠘⡆⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠁⠈⡏⠀⡿⠀⢿⠀⢹⠃⢸⡇⠘⡇⠀⡜⡇⣸⡇⢸⢧⢠⢿⠀⣿⠀⡾⡄⡸⡟⠀⣷⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢆⢰⢳⢀⢿⠀⡿⡄⡼⡆⣸⣇⢰⢧⢠⠇⣧⡇⢹⡞⠸⡼⠘⣾⠁⣷⠃⢧⢧⢷⢀⡟⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢘⣎⢈⣞⠀⣿⡁⣳⡃⣹⡇⢸⣏⢘⣞⢀⡿⢆⡼⢧⣰⢳⣠⠿⣀⠾⣄⡞⣆⢈⣿⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢹⣾⣿⣾⣿⣶⣿⣧⣿⣷⣿⣷⣾⣿⣼⣿⣷⣾⣷⣾⣵⣲⣽⣶⣿⣶⣯⣶⣼⣿⣾⣿⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      └────────────────────────────────────────┘\n      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀\n\njulia> gt = ground_track(orbp, track_types = :ascending);\n\njulia> lineplot(last.(gt), first.(gt))\n      ┌────────────────────────────────────────┐\n    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢸⡛⠽⡛⠿⣟⠫⣟⠫⢍⠛⠻⢿⡻⢽⡛⡿⡛⠿⣟⠯⣟⠫⢟⠻⢿⡛⢽⡛⠽⡛⠯⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠹⡄⠘⡆⠈⢆⠈⢣⠀⢳⡀⠀⢳⡀⠹⡇⠙⡆⠈⢆⠈⢧⠀⢳⡀⠱⡀⠙⡄⠘⣆⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢦⠀⢱⠀⢸⡀⠘⡄⠈⡇⠀⣇⠀⠀⢧⠀⣷⠀⢸⠀⠸⡄⠈⡆⠀⣇⠀⢣⠀⢹⠀⠈⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢸⡀⠘⡆⠀⡇⠀⢇⠀⢹⠀⢸⠀⠀⢸⠀⡟⡆⠀⡇⠀⣇⠀⢳⠀⢸⠀⠸⡀⠈⡇⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⡇⠀⣇⠀⢳⠀⢸⠀⠸⡀⠈⡇⠀⠀⡇⡇⡇⠀⢳⠀⢸⠀⢸⡀⠈⡆⠀⡇⠀⢧⠀⠀⠀⠀⠀│\n      │⠤⠤⠤⠤⠤⢧⠤⢼⠤⢼⠤⠼⡦⠤⡧⠤⣧⠤⠤⢧⡧⢼⠤⢼⠤⠼⡤⠤⡧⠤⡧⠤⢷⠤⢼⠤⠤⠤⠤⠤│\n      │⠀⠀⠀⠀⠀⢸⠀⠸⡄⠀⡇⠀⡇⠀⢳⠀⢸⠀⠀⢸⡇⠸⡄⠈⡇⠀⡇⠀⢧⠀⢸⠀⢸⠀⠘⡆⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠈⡇⠀⡇⠀⢧⠀⢹⠀⢸⡀⠘⡆⠀⠘⡇⠀⡇⠀⢧⠀⢹⠀⢸⠀⠸⡄⠈⡇⠀⣇⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢆⠀⢳⠀⢸⠀⠸⡄⠘⡆⠀⣇⠀⢧⠀⠀⣧⠀⢹⠀⠸⡀⠘⡆⠀⣇⠀⢧⠀⢳⠀⠘⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠘⣆⠈⢆⠀⢧⡀⢳⡀⠹⡄⠘⣄⠘⣆⠀⡏⢆⠀⢧⠀⢳⡀⠹⡀⠸⣄⠘⣆⠈⢧⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠐⣬⣗⣮⣷⣦⣵⣢⣽⣲⣽⣶⣬⣗⣬⣗⣧⣬⣓⣦⣵⣢⣽⣲⣽⣶⣬⣖⣬⣗⣮⡵⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      └────────────────────────────────────────┘\n      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀\n\njulia> gt = ground_track(orbp, track_types = :descending);\n\njulia> lineplot(last.(gt), first.(gt))\n      ┌────────────────────────────────────────┐\n    2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⣸⡽⠟⣻⠽⣻⠿⢛⡯⢛⡯⢟⡻⠝⣻⠝⣿⠽⢛⠯⢛⡯⢛⡿⠟⡻⠝⣻⠽⣻⠿⢓⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠞⠀⡼⠁⣰⠃⢰⠋⢠⠏⢀⡞⠀⡜⠁⡼⡇⣰⠃⢠⠏⢀⠎⠀⡞⠀⡼⠁⣰⠃⢰⣫⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⢰⠃⢠⠇⠀⡏⠀⡞⠀⡸⠀⢸⠁⢰⠃⣇⡇⠀⡏⠀⡼⠀⣸⠀⢰⠃⢠⠇⠀⣏⠇⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⡞⠀⣸⠀⢸⠁⢠⠃⠀⡇⠀⡏⠀⡼⠀⣿⠀⢰⠁⢀⡇⠀⡇⠀⡞⠀⣸⠀⢸⢸⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢀⡇⠀⡇⠀⡜⠀⢸⠀⢸⠁⢠⠇⠀⡇⠀⡏⠀⣸⠀⢸⠀⢰⠃⢀⡇⠀⡇⠀⡜⡏⠀⠀⠀⠀⠀│\n      │⠤⠤⠤⠤⢼⠤⢤⠧⠤⡧⠤⡯⠤⡼⠤⢼⠤⢴⠥⢤⡧⠤⡧⠤⡾⠤⢼⠤⢼⠤⢤⠧⠤⣧⠧⠤⠤⠤⠤⠤│\n      │⠀⠀⠀⠀⡼⠀⢸⠀⢸⠁⢀⠇⠀⡇⠀⡞⠀⢸⠀⢸⡇⢠⠃⠀⡇⠀⡏⠀⡼⠀⢸⠀⢸⢹⠀⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠁⠀⡎⠀⡸⠀⢸⠀⢰⠃⢀⡇⠀⡇⠀⡜⡇⣸⠀⢸⠁⢠⠇⠀⡇⠀⡎⠀⡸⡞⠀⣰⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⢰⠃⢀⠇⠀⡏⠀⡼⠀⣸⠀⢰⠁⢠⠇⣇⡇⠀⡞⠀⡼⠀⢸⠁⢰⠃⢀⢧⠇⢀⡇⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢀⠎⢀⡞⠀⡼⠁⡰⠃⣠⠃⢠⠏⢀⡞⢀⡿⠀⡼⠁⣰⠃⢠⠇⢀⠎⢀⡞⠀⢀⡜⠀⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⢩⣖⣯⣔⣮⣴⣾⣥⣺⣥⣲⣥⣖⣯⣔⣯⣷⣾⣵⣺⣥⣲⣥⣶⣯⣖⣋⣤⣔⣯⣔⣎⠀⠀⠀⠀│\n      │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n   -2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│\n      └────────────────────────────────────────┘\n      ⠀-4⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.ground_track_inclination-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteAnalysis.ground_track_inclination","text":"ground_track_inclination(a::Number, e::Number, i::Number; kwargs...) -> T\nground_track_inclination(orb::Orbit{Tepoch, T}); kwargs...) where {Tepoch <: Number, T <: Number} -> T\n\nCompute the ground track inclination at the Equator [rad] in an orbit with semi-major axis a [m], eccentricity e [ ], and inclination i [rad]. The orbit can also be specified by orb (see Orbit).\n\nnote: Note\nThe output type T in the first signature is obtained by promoting the inputs to a float type.\n\nwarning: Warning\nThe algorithm here assumes a small orbit eccentricity.\n\nKeywords\n\nperturbation::Symbol: Symbol to select the perturbation terms that will be used. It can   be :J0, :J2, or :J4.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default: GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default: EGM_2008_J2)\nJ4::Number: J₄ perturbation term.   (Default: EGM_2008_J4)\nR0::Number: Earth's equatorial radius [m].   (Default: EARTH_EQUATORIAL_RADIUS)\nwe::Number: Earth's angular speed [rad / s].   (Default: EARTH_ANGULAR_SPEED)\n\nExtended Help\n\nWe define the ground track inclination as the angle that the ground track has with respect to the Equator. This information is important to compute, for example, the required swath for a remote sensing satellite to cover the entire Earth.\n\nThe ground track inclination i_gt is given by:\n\n            ┌                       ┐\n            │      ω_s ⋅ sin i      │\ni_gt = atan │ ───────────────────── │\n            │ ω_s ⋅ cos i - ω_e + Ω̇ │\n            └                       ┘\n\nwhere ω_s = n + ω̇ is the satellite angular velocity, n is the perturbed mean motion, i is the orbit inclination, ω is the orbit argument of perigee, Ω is the orbit right ascension of the ascending node, and ω_e is the Earth's angular rate.\n\nFormally, we should use the satellite instantaneous angular speed at the Equator instead of the mean angular speed ω_s. However, given the perturbations caused by the Earth's gravitational potential, the former is not simple to compute. This calculation would required to implement an orbit propagator here. Thus, we simplify it by assuming that the orbit eccentricity is small. This assumption is reasonable given the missions that would benefit from the computation of the ground track inclination. In this case, the orbit angular speed is almost constant and equal to ω_s.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> ground_track_inclination(7130.982e3, 0.00111, 98.410 |> deg2rad) |> rad2deg\n102.30052101661899\n\njulia> jd₀ = date_to_jd(2021, 1, 1)\n2.4592155e6\n\njulia> orb = KeplerianElements(\n           jd₀,\n           7130.982e3,\n           0.001111,\n           98.410 |> deg2rad,\n           ltdn_to_raan(10.5, jd₀),\n           π / 2,\n           0\n       )\nKeplerianElements{Float64, Float64}:\n           Epoch :    2.45922e6 (2021-01-01T00:00:00)\n Semi-major axis : 7130.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.41     °\n            RAAN :   78.4021   °\n Arg. of Perigee :   90.0      °\n    True Anomaly :    0.0      °\n\njulia> ground_track_inclination(orb) |> rad2deg\n102.30052101658998\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.is_ground_facility_visible-Tuple{AbstractVector, AbstractVector, Number}","page":"Library","title":"SatelliteAnalysis.is_ground_facility_visible","text":"is_ground_facility_visible(sat_r_e::AbstractVector, gf_r_e::AbstractVector, θ::Number) -> Bool\n\nCheck if the satellite with position vector sat_r_e (ECEF) is inside the visibility circle of a ground facility with position vector gf_r_e (ECEF) and a minimum elevation angle of θ [rad].\n\nNotice that sat_r_e and gf_r_e must be represented in the same ECEF frame, and must have the same unit.\n\nReturns\n\nBool: true if the satellite is inside the visibility circle, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.is_ground_facility_visible-Tuple{AbstractVector, Vararg{Number, 4}}","page":"Library","title":"SatelliteAnalysis.is_ground_facility_visible","text":"is_ground_facility_visible(sat_r_e::AbstractVector, gf_lat::Number, gf_lon::Number, gf_h::Number, θ::Number) -> Bool\n\nCheck if the satellite with position vector sat_r_e (ECEF) is inside the visibility circle of a ground facility with latitude gf_lat [rad], longitude gf_lon [rad], altitude gf_h (WGS-84), and a minimum elevation angle of θ [rad].\n\nNotice that sat_r_e and gf_h must have the same units.\n\nReturns\n\nBool: true if the satellite is inside the visibility circle, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.lighting_condition-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"SatelliteAnalysis.lighting_condition","text":"lighting_condition(r_i::AbstractVector, s_i::AbstractVector)\n\nCompute the lighting condition at the position r_i [m] considering the Sun position vector s_i [m]. The possible return values are:\n\n:sunlight: The point is under direct sunlight.\n:penumbra: The point is in penumbra region.\n:umbra: The point is in umbra region.\n\nThe algorithm used in this function was based on [1].\n\nnote: Note\nThe vectors r_i and s_i must be represented in the same reference frame.\n\nReferences\n\n[1] Longo, C. R. O., Rickman, S. L (1995). Method for the Calculation of Spacecraft   Umbra and Penumbra Shadow Terminator Points. NASA Technical Paper 3547.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.sun_sync_orbit_from_angular_velocity-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Library","title":"SatelliteAnalysis.sun_sync_orbit_from_angular_velocity","text":"sun_sync_orbit_from_angular_velocity(angvel::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, T, Bool\n\nCompute the Sun-synchronous orbit semi-major axis [m] and inclination [rad] given the angular velocity angvel [rad / s] and the orbit eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.\n\nThe algorithm here considers only the perturbation terms up to J₂.\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nmax_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 3)\nno_warnings::Bool: If true, no warnings will be printed.   (Default = false)\ntolerance::Union{Nothing, NTuple{2, Number}}: Residue tolerances to verify if the   numerical method has converged. If it is nothing, (√eps(T), √eps(T)) will be used,   where T is the internal type for the computations. Notice that the residue function   f₁ unit is [deg / day], whereas the f₂ unit is [deg / min].   (Default = 1e-18)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\nReturns\n\nT: Semi-major axis [m].\nT: Inclination [rad].\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.\n\nExtended help\n\nA Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth's orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.\n\nThe RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:\n\n∂Ω      3                       n̄\n── = - ─── R₀² . J₂ . cos(i) . ─── .\n∂t      2                       p²\n\nwhere:\n\n         ┌                                                ┐\n         │      3    R₀²                                  │\nn̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.\n         │      4     p²                                  │\n         └                                                ┘\n\nWe can express the orbit angular velocity in terms of its nodal period, i.e., the period it takes for the satellite to cross the ascending node two consecutive times:\n\n          ∂M     ∂ω\nangvel = ──── + ────,\n          ∂t     ∂t\n\n                  3    R₀²\nangvel = n̄ + n̄ . ─── . ─── . J₂ . (4 - 5sin²(i)),\n                  4     p²\n\nwhere n is the perturbed mean motion due to the same consideration as presented for the RAAN time-derivative.\n\nFinally, this function finds the pair (a, i) that simultaneously solves the equations:\n\n∂Ω\n── (a, i) = EARTH_ORBIT_MEAN_MOTION,\n∂t\n\n ∂M            ∂ω\n──── (a, i) + ──── (a, i) = angvel,\n ∂t            ∂t\n\nusing the Newton-Raphson method with the presented equations.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad)\n(7.130983932846816e6, 1.7175898375139984, true)\n\njulia> sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad, 0)\n(7.130983932846816e6, 1.7175898375139984, true)\n\njulia> sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad, 0.1)\n(7.13086251587883e6, 1.7146410689929386, true)\n\nThe user can verify some internal information of the solver by turning on the debugging logs:\n\njulia> with_logger(ConsoleLogger(stderr, Logging.Debug)) do\n           sun_sync_orbit_from_angular_velocity(0.06 |> deg2rad)\n       end\n┌ Debug: Iteration #1\n│   Estimation :\n│     a  = 7136.635455699327 km\n│     i  = 81.57099271530629 °\n│   Residues :\n│     f₁ = 1.9706966881670205 ° / day\n│     f₂ = 0.004266929859281898 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n┌ Debug: Iteration #2\n│   Estimation :\n│     a  = 7128.856266265137 km\n│     i  = 98.46515928332974 °\n│   Residues :\n│     f₁ = -0.0073785260175135425 ° / day\n│     f₂ = -0.0016144146737784304 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n┌ Debug: Iteration #3\n│   Estimation :\n│     a  = 7130.983594940013 km\n│     i  = 98.41070350863473 °\n│   Residues :\n│     f₁ = -6.549620124363109e-6 ° / day\n│     f₂ = -2.6066638092459016e-7 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n┌ Debug: Iteration #4\n│   Estimation :\n│     a  = 7130.983932846698 km\n│     i  = 98.41064862339992 °\n│   Residues :\n│     f₁ = 8.290634845309341e-11 ° / day\n│     f₂ = -2.2648549702353193e-14 ° / min\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:394\n(7.130983932846816e6, 1.7175898375139984, true)\n\nReferences\n\n[1] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.sun_sync_orbit_inclination-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Library","title":"SatelliteAnalysis.sun_sync_orbit_inclination","text":"sun_sync_orbit_inclination(a::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, Bool\n\nCompute the inclination [rad] of the Sun-synchronous orbit with semi-major axis a [m] and the eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.\n\nThe algorithm here considers only the perturbation terms up to J₂.\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nmax_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 30)\ntolerance::Union{Nothing, Number}: Residue tolerance to verify if the numerical method   has converged. If it is nothing, √eps(T) will be used, where T is the internal   type for the computations. Notice that the residue unit is [deg / day].   (Default = nothing)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\nReturns\n\nT: Inclination [rad] of the Sun-synchronous orbit with semi-major axis a and   eccentricity e.\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.\n\nExtended help\n\nA Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth's orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.\n\nThe RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:\n\n∂Ω      3                       n̄\n── = - ─── R₀² . J₂ . cos(i) . ─── .\n∂t      2                       p²\n\nwhere:\n\n         ┌                                                ┐\n         │      3    R₀²                                  │\nn̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.\n         │      4     p²                                  │\n         └                                                ┘\n\nFinally, this function solves the equation:\n\n∂Ω\n── (i) = EARTH_ORBIT_MEAN_MOTION\n∂t\n\nfor i using the Newton-Raphson method with the presented equations.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> sun_sync_orbit_inclination(7130.982e3)\n(1.7175896973066611, true)\n\njulia> sun_sync_orbit_inclination(7130.982e3, 0)\n(1.7175896973066611, true)\n\njulia> sun_sync_orbit_inclination(7130.982e3, 0.001111)\n(1.7175893324980402, true)\n\nThe user can verify some internal information of the solver by turning on the debugging logs:\n\njulia> with_logger(ConsoleLogger(stderr, Logging.Debug)) do\n           sun_sync_orbit_inclination(7130.982e3)\n       end\n┌ Debug: Iteration #1\n│   Estimation : 98.41064059121584 °\n│   Residue    : 0.0005992085524891833 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:686\n┌ Debug: Iteration #2\n│   Estimation : 98.41064059082426 °\n│   Residue    : -4.556321986370904e-11 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:686\n(1.7175896973066611, true)\n\nReferences\n\n[1] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteAnalysis.sun_sync_orbit_semi_major_axis-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Library","title":"SatelliteAnalysis.sun_sync_orbit_semi_major_axis","text":"sun_sync_orbit_semi_major_axis(i::T1, e::T2 = 0; kwargs...) where {T1 <: Number, T2 <: Number} -> T, Bool\n\nCompute the semi-major axis [m] of the Sun-synchronous orbit with inclination i [rad] and the eccentricity e [ ]. If the latter is omitted, the orbit is considered circular, i.e., e = 0.\n\nThe algorithm here considers only the perturbation terms up to J₂.\n\nnote: Note\nInternally, this function uses the precision obtained by promoting T1 and T2 to a float-pointing number T.\n\nKeywords\n\nmax_iterations::Number: Maximum number of iterations in the Newton-Raphson method.   (Default = 30)\ntolerance::Union{Nothing, Number}: Residue tolerance to verify if the numerical method   has converged. If it is nothing, √eps(T) will be used, where T is the internal   type for the computations. Notice that the residue unit is [deg / day].   (Default = nothing)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term.   (Default = EGM_2008_J2)\nR0::Number: Earth's equatorial radius [m].   (Default = EARTH_EQUATORIAL_RADIUS)\n\nReturns\n\nT: Semi-major axis [m] of the Sun-synchronous orbit with inclination i and   eccentricity e.\nBool: true if the Newton-Raphson algorithm converged, or false otherwise.\n\nExtended help\n\nA Sun-synchronous orbit is defined as an orbit in which the precession of the right ascension of the ascending node (RAAN) equals the Earth's orbit mean motion. In this case, the orbit plane will have the same orientation to the Sun at the ascending node.\n\nThe RAAN time-derivative considering only the secular terms up to J₂ is [1, p. 372] is:\n\n∂Ω      3                       n̄\n── = - ─── R₀² . J₂ . cos(i) . ─── .\n∂t      2                       p²\n\nwhere:\n\n         ┌                                                ┐\n         │      3    R₀²                                  │\nn̄ = n₀ . │ 1 + ─── . ─── . J₂ . √(1 - e²) . (2 - 3sin²(i))│.\n         │      4     p²                                  │\n         └                                                ┘\n\nFinally, this function solves the equation:\n\n∂Ω\n── (a) = EARTH_ORBIT_MEAN_MOTION\n∂t\n\nfor a using the Newton-Raphson method with the presented equations.\n\nExamples\n\njulia> using SatelliteAnalysis\n\njulia> sun_sync_orbit_semi_major_axis(98.410 |> deg2rad)\n(7.130827866508738e6, true)\n\njulia> sun_sync_orbit_semi_major_axis(98.410 |> deg2rad, 0)\n(7.130827866508738e6, true)\n\njulia> sun_sync_orbit_semi_major_axis(98.410 |> deg2rad, 0.001111)\n(7.1308328955274355e6, true)\n\nThe user can verify some internal information of the solver by turning on the debugging logs:\n\njulia> with_logger(ConsoleLogger(stderr, Logging.Debug)) do\n           sun_sync_orbit_semi_major_axis(98.41064163374567 |> deg2rad)\n       end\n┌ Debug: Iteration #1\n│   Estimation : 7130.981820550704 km\n│   Residue    : 0.0005989504045072862 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559\n┌ Debug: Iteration #2\n│   Estimation : 7130.982250931794 km\n│   Residue    : -2.081337784770338e-7 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559\n┌ Debug: Iteration #3\n│   Estimation : 7130.982250931845 km\n│   Residue    : -2.4312691616901194e-14 ° / day\n└ @ SatelliteAnalysis ~/.julia/dev/SatelliteAnalysis/src/sun_synchronous_orbits.jl:559\n(7.130982250931845e6, true)\n\nReferences\n\n[1] Kozai, Y (1959). The Motion of a Close Earth Satellite. The Astronomical Journal,   v. 64, no. 1274, pp. 367 – 377.\n\n\n\n\n\n","category":"method"},{"location":"man/beta_angle/#Beta-Angle","page":"Beta Angle","title":"Beta Angle","text":"","category":"section"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"using SatelliteAnalysis","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The beta angle is the angle between the orbit plane and the Sun, as shown in the following figure. The positive direction is defined as that of the orbit angular momentum.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The beta angle is useful when computing the mean amount of solar radiation a satellite receives in a particular orbit.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"<div align=\"center\">\n  <img src=\"../../assets/beta_angle.png\" alt=\"Beta Angle\" width=\"50%\"/>\n</div>","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"We can compute the beta angle of an orbit using the function:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"beta_angle(orb::KerplerianElements{Tepoch, T}, Δjd::Number; kwargs...) -> Float64","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"This function computes the beta angle [rad] for the orbit orb after Δjd days from its epoch.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The algorithm was obtained from [1].","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"note: Note\nIt is expected that the input elements are represented in the TOD reference frame. If it is not the case, they can be converted using the function orb_eci_to_eci of SatelliteToolboxTransformations.jl.","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"The following keywords are available:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"perturbation::Symbol: Select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J₂.\n:J4: Consider the perturbation terms J₂, J₂², and J₄.\n(Default: :J2)","category":"page"},{"location":"man/beta_angle/#Examples","page":"Beta Angle","title":"Examples","text":"","category":"section"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"We will compute the beta angle of the Amazonia-1 mission for one year. The first thing we need to do is define the orbit:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"jd₀ = date_to_jd(2021, 1, 1)\n\norb = KeplerianElements(\n    jd₀,\n    7130.982e3,\n    0.001111,\n    98.405 |> deg2rad,\n    ltdn_to_raan(10.5, jd₀),\n    π / 2,\n    0\n)","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"Now, we can use the function beta_angle to obtain the beta angle [rad] for each day of the year:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"β = beta_angle.(orb, 1:365)","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"If we use CairoMakie.jl to plot, we obtain:","category":"page"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"<div align=\"center\">\n  <img src=\"../../assets/beta_angle_amz1.png\" alt=\"Beta Angle of the Amazonia-1 Mission\" width=\"100%\"/>\n</div>","category":"page"},{"location":"man/beta_angle/#References","page":"Beta Angle","title":"References","text":"","category":"section"},{"location":"man/beta_angle/","page":"Beta Angle","title":"Beta Angle","text":"[1]: Mortari, D., Wilkins, M. P., and Bruccoleri, C. On Sun-Synchronous Orbits and Associated Constellations.","category":"page"},{"location":"man/eclipse_time/#Eclipse-Time","page":"Eclipse Time","title":"Eclipse Time","text":"","category":"section"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"using SatelliteAnalysis","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The eclipse time is the period the satellite does not receive sunlight due to the Earth shadow. This information is paramount for mission design since it directly interferes in the power and thermal subsystems.","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"We can compute the eclipse time of a satellite using the function:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"eclipse_time_summary(orbp::OrbitPropagator; kwargs...) -> DataFrame","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"This function computes the eclipse time summary for the orbit propagator orbp. The summary is computed as the total time the object stays in the sunlight, penumbra, and umbra regions per orbit at each day. The algorithm was adapted from [1].","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The following keywords are available:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"num_days::Number: Number of days in which the analysis will be performed. (Default = 365)\nstep::Number: The step in which the propagation will occur. Notice that this function has a crossing estimation to accurately estimate the transition between the regions. However, if this step is very large, we may miss some small regions. If it is negative, it will be selected as the time in which the mean anomaly advances 0.5°. (Default = -1)\nunit::Symbol: Select the unit in which the results will be generated. The possible values are:\n:s for seconds (Default);\n:m for minutes; or\n:h for hours.","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The function returns a DataFrame with three columns:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"sunlight: Total sunlight time per orbit at each day [unit].\npenumbra: Total penumbra time per orbit at each day [unit].\numbra: Total umbra time per orbit at each day [unit].","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The unit of each column is stored in the DataFrame using metadata.","category":"page"},{"location":"man/eclipse_time/#Examples","page":"Eclipse Time","title":"Examples","text":"","category":"section"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"We will compute the eclipse time of the Amazonia-1 mission for one year. The first thing we need to do is define the orbit:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"jd₀ = date_to_jd(2021, 1, 1)\n\norb = KeplerianElements(\n    jd₀,\n    7130.982e3,\n    0.001111,\n    98.405 |> deg2rad,\n    ltdn_to_raan(10.5, jd₀),\n    π / 2,\n    0\n)","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"The next step is to define the desired propagator:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"orbp = Propagators.init(Val(:J2), orb)","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"Now, we can use the function eclipse_time_summary to obtain the eclipse time information for each day of the year:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"df = eclipse_time_summary(orbp; unit = :m)","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"Finally, we can use the DataFrame to analyze the result. For example, the maximum eclipse time in an orbit is:","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"maximum(df.penumbra .+ df.umbra)","category":"page"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"i.e., 34.66 minutes.","category":"page"},{"location":"man/eclipse_time/#References","page":"Eclipse Time","title":"References","text":"","category":"section"},{"location":"man/eclipse_time/","page":"Eclipse Time","title":"Eclipse Time","text":"[1] Longo, C. R. O., Rickman, S. L (1995). Method for the Calculation of Spacecraft Umbra and Penumbra Shadow Terminator Points. NASA Technical Paper 3547.","category":"page"},{"location":"man/frozen_orbits/#Frozen-Orbits","page":"Frozen Orbits","title":"Frozen Orbits","text":"","category":"section"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"CurrentModule = SatelliteAnalysis","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"using SatelliteAnalysis","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"Due to the Earth's gravitational perturbation, the orbit of a salite will experience secular changes in the argument of perigee. Hence, the satellite mean altitude per latitude will differ during the mission. This effect can be problematic, especially if we must compare images by a camera onboard the satellite in different periods. The altitude variation will change the resolution, leading to some problems when comparing the data.","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"We can avoid this problem if we compute an eccentricity e  and the argument of perigee omega that yields theoretically:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"beginequation*\n  fracdedt = 0 fracdomegadt = 0 \nendequation*","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"This orbit is called frozen. Refer to [1] for more information.","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"We can use the function:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"frozen_orbit(a::Number, i::Number; kwargs...) -> Float64, Float64","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"to compute the eccentricity [ ] and argument of perigee [rad] that yield a frozen orbit when the orbit has semi-major axis a [m] and inclination i [rad]. This function uses the theory in [1].","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"note: Note\nThis function uses BigFloat internally to perform all computations, allowing very high degrees. However, the user must ensure that the default precision is enough for the required degree. Refer to the function setprecision for more information.","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"The following keywords are available:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"gravity_model::Union{Nothing, AbstractGravityModel}: Gravity model used to compute the   frozen eccentricity. Refer to the object AbstractGravityModel of the package   SatelliteToolboxGravityModels.jl for more information. If it is nothing, the system   will automatically fetch and load the EGM96 gravity model. However, loading a gravity   model can significantly decrease the performance. Thus, it is advisable to pass a   gravity model here.   (Default = nothing)\nmax_degree: Maximum gravity model degree used to compute the frozen eccentricity. If it   is equal to or lower than 0, the maximum degree in grav_model will be used. Otherwise,   if it is lower than 3 or higher than the grav_model maximum degree, it will be clamped   accordingly.   (Default = 53)","category":"page"},{"location":"man/frozen_orbits/#Examples","page":"Frozen Orbits","title":"Examples","text":"","category":"section"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"We will compute the eccentricity and argument of perigee that yields a frozen orbit using the data from Amazonia-1 mission. First, we will use only 5 degrees, and the default gravity model (EGM96):","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"frozen_orbit(7130.982e3, 98.410 |> deg2rad; max_degree = 5)\n\ne, ω = frozen_orbit(7130.982e3, 98.410 |> deg2rad; max_degree = 5)\n\ne\n\nω |> rad2deg","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"If we want to use all the 360 terms in EGM96, we need to increase the precision of BigFloat to keep the accuracy:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"setprecision(1024)\n\ne, ω = frozen_orbit(7130.982e3, 98.410 |> deg2rad; max_degree = 5)\n\ne\n\nω |> rad2deg","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"We can use a different gravity model as follows:","category":"page"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"jgm3 = GravityModels.load(IcgemFile, fetch_icgem_file(:JGM3))\n\ne, ω = frozen_orbit(7130.982e3, 98.410 |> deg2rad; max_degree = 70, gravity_model = jgm3)\n\ne\n\nω |> rad2deg","category":"page"},{"location":"man/frozen_orbits/#References","page":"Frozen Orbits","title":"References","text":"","category":"section"},{"location":"man/frozen_orbits/","page":"Frozen Orbits","title":"Frozen Orbits","text":"[1] Rosborough, G. W.; Ocampo, C. A (1991). Influence of higher degree zonals on the frozen orbit geometry. Proceedings of the AAS/AIAA Astrodynamics Conference, Durango, CO.","category":"page"},{"location":"#SatelliteAnalysis.jl","page":"Home","title":"SatelliteAnalysis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SatelliteAnalysis\nDocTestSetup = quote\n    using SatelliteAnalysis\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains several functions to perform analysis related to satellites. Those functions were split from the package SatelliteToolbox.jl.","category":"page"},{"location":"#Instalation","page":"Home","title":"Instalation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"SatelliteAnalysis\")","category":"page"}]
}
