<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sun Synchronous Orbits · Satellite Analysis</title><meta name="title" content="Sun Synchronous Orbits · Satellite Analysis"/><meta property="og:title" content="Sun Synchronous Orbits · Satellite Analysis"/><meta property="twitter:title" content="Sun Synchronous Orbits · Satellite Analysis"/><meta name="description" content="Documentation for Satellite Analysis."/><meta property="og:description" content="Documentation for Satellite Analysis."/><meta property="twitter:description" content="Documentation for Satellite Analysis."/><meta property="og:url" content="https://juliaspace.github.io/SatelliteAnalysis.jl/stable/man/orbits/sun_synchronous_orbits/"/><meta property="twitter:url" content="https://juliaspace.github.io/SatelliteAnalysis.jl/stable/man/orbits/sun_synchronous_orbits/"/><link rel="canonical" href="https://juliaspace.github.io/SatelliteAnalysis.jl/stable/man/orbits/sun_synchronous_orbits/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="Satellite Analysis logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Satellite Analysis</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../beta_angle/">Beta Angle</a></li><li><a class="tocitem" href="../../eclipse_time/">Eclipse Time</a></li><li><a class="tocitem" href="../../frozen_orbits/">Frozen Orbits</a></li><li><span class="tocitem">Ground Facilities</span><ul><li><a class="tocitem" href="../../ground_facilities/ground_facility_accesses/">Ground Facility Accesses</a></li><li><a class="tocitem" href="../../ground_facilities/ground_facility_gaps/">Ground Facility Gaps</a></li><li><a class="tocitem" href="../../ground_facilities/ground_facility_visibility_circle/">Ground Facility Visibility Circle</a></li></ul></li><li><a class="tocitem" href="../../ground_track/">Ground Track</a></li><li><span class="tocitem">Orbits</span><ul><li class="is-active"><a class="tocitem" href>Sun Synchronous Orbits</a><ul class="internal"><li><a class="tocitem" href="#Designing-Sun-Synchronous-Orbits-from-Angular-Velocity"><span>Designing Sun-Synchronous Orbits from Angular Velocity</span></a></li><li><a class="tocitem" href="#Designing-Sun-Synchronous-Orbits-from-Semi-Major-Axis"><span>Designing Sun-Synchronous Orbits from Semi-Major Axis</span></a></li><li><a class="tocitem" href="#Designing-Sun-Synchronous-Orbits-from-Inclination"><span>Designing Sun-Synchronous Orbits from Inclination</span></a></li><li><a class="tocitem" href="#Designing-Sun-Synchronous,-Ground-Repeating-Orbits"><span>Designing Sun-Synchronous, Ground-Repeating Orbits</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../../lib/library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Orbits</a></li><li class="is-active"><a href>Sun Synchronous Orbits</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sun Synchronous Orbits</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSpace/SatelliteAnalysis.jl/blob/main/docs/src/man/orbits/sun_synchronous_orbits.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sun-Synchronous-Orbits"><a class="docs-heading-anchor" href="#Sun-Synchronous-Orbits">Sun-Synchronous Orbits</a><a id="Sun-Synchronous-Orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Sun-Synchronous-Orbits" title="Permalink"></a></h1><p>Given the Earth&#39;s gravitational potential, all the low Earth orbits (LEO) suffer from perturbations in their elements. The right ascension of the ascending node (RAAN) is one of the elements that see a secular perturbation. Hence, we can use this effect to design orbits that the RAAN time derivative matches that of the Earth&#39;s orbit around the Sun. In this case, the orbit plane keeps its geometry almost constant regarding the Sun vector. Hence, the apparent local time of the ascending or descending node (LTAN and LTDN) will also be almost invariable, as shown in the following figure:</p><div align="center">
  <img src="../../../assets/sun_sync_orbit_plane.png" alt="Orbit Plane in Sun-Synchronous Orbits" width="100%"/>
</div><p>In fact, if the Earth was a perfect sphere, no secular perturbation would be seen in RAAN. Hence, the LTAN would have a variation of 24 hours in a year.</p><p>Considering only terms up to <span>$J_2$</span>, which is the dominant effect, the RAAN time derivative is:</p><p class="math-container">\[\frac{d\Omega}{dt} = -\frac{2}{3} J_2 \left(\frac{R_0}{p_0}\right)^2 \bar{n} \cos i_0\ ,\]</p><p>where <span>$R_0$</span> is the Earth&#39;s Equatorial radius, <span>$i_0$</span> is the orbit inclination, <span>$p_0 = a_0 (1 - e_0^2)$</span>, <span>$a_0$</span> is the orbit semi-major axis, and <span>$e_0$</span> is the orbit eccentricity, and <span>$\bar{n}$</span> is the perturbed mean-motion, given by:</p><p class="math-container">\[\bar{n} = n_0 \left[1 + \frac{3}{4} J_2 \left(\frac{R_0}{p_0}\right)^2 \sqrt{1 - e_0^2} \left(2 - 3\sin^2 i_0\right)\right]\ ,\]</p><p>where <span>$n_0 = \sqrt{\mu / a^3}$</span>, and <span>$\mu$</span> is the Earth&#39;s standard gravitational parameter.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Formally, all quantities on the right-hand side of those equations must be the mean elements instead of the initial ones. However, we are considering only the secular perturbations caused by the <span>$J_2$</span> term. Thus, the semi-major axis, eccentricity, and inclination do not suffer from secular effects.</p></div></div><p>Finally, we can design a Sun-syncrhonous orbit by selecting the semi-major axis and inclination that leads to:</p><p class="math-container">\[\frac{d\Omega}{dt} = 0.9856473598947981^\circ / s\ .\]</p><h2 id="Designing-Sun-Synchronous-Orbits-from-Angular-Velocity"><a class="docs-heading-anchor" href="#Designing-Sun-Synchronous-Orbits-from-Angular-Velocity">Designing Sun-Synchronous Orbits from Angular Velocity</a><a id="Designing-Sun-Synchronous-Orbits-from-Angular-Velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Designing-Sun-Synchronous-Orbits-from-Angular-Velocity" title="Permalink"></a></h2><p>The satellite orbital angular velocity <span>$\omega_o$</span> is:</p><p class="math-container">\[\omega_{o}(a_0, i_0) = \frac{dM}{dt} + \frac{d\omega}{dt}\ ,\]</p><p>where <span>$M$</span> is the mean anomaly, and <span>$\omega$</span> is the argument of perigee. Considering only the secular effects caused by the <span>$J_2$</span> term, one gets:</p><p class="math-container">\[\begin{aligned}
  \frac{dM}{dt} &amp;= \bar{n}\ , \\
  \frac{d\omega}{dt} &amp;= \frac{3}{4} J_2 \left(\frac{R_0}{p_0}\right)^2 \bar{n} \left(4 - 5\sin^2 i_0\right)\ .
\end{aligned}\]</p><p>Thus, given a desired angular velocity <span>$n_d$</span>, we can find the semi-major axis and inclination that leads to a Sun-synchronous orbit by numerically solving the system:</p><p class="math-container">\[\begin{aligned}
  \frac{d\Omega}{dt}(a_0, i_0) &amp;= 0.9856473598947981^\circ / s\ , \\
  \bar{n}(a_0, i_0) &amp;= n_d\ .
\end{aligned}\]</p><p>The function:</p><pre><code class="language-julia hljs">sun_sync_orbit_from_angular_velocity(angvel::T1, e::T2 = 0; kwargs...) where {T1 &lt;: Number, T2 &lt;: Number} -&gt; T, T, Bool</code></pre><p>computes the Sun-synchronous orbit semi-major axis [m] and inclination [rad] given the angular velocity <code>angvel</code> [rad / s] and the orbit eccentricity <code>e</code> [ ]. If the latter is omitted, the orbit is considered circular, <em>i.e.</em>, <code>e = 0</code>.</p><p>The algorithm here considers only the perturbation terms up to <span>$J_2$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Internally, this function uses the precision obtained by promoting <code>T1</code> and <code>T2</code> to a float-pointing number <code>T</code>.</p></div></div><p>The following keywords are available:</p><ul><li><code>max_iterations::Number</code>: Maximum number of iterations in the Newton-Raphson method.   (<strong>Default</strong> = 3)</li><li><code>no_warnings::Bool</code>: If <code>true</code>, no warnings will be printed.   (<strong>Default</strong> = <code>false</code>)</li><li><code>tolerance::Union{Nothing, NTuple{2, Number}}</code>: Residue tolerances to verify if the   numerical method has converged. If it is <code>nothing</code>, <code>(√eps(T), √eps(T))</code> will be used,   where <code>T</code> is the internal type for the computations. Notice that the residue function   <code>f₁</code> unit is [deg / day], whereas the <code>f₂</code> unit is [deg / min].   (<strong>Default</strong> = 1e-18)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong> = <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong> = <code>EGM_2008_J2</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong> = <code>EARTH_EQUATORIAL_RADIUS</code>)</li></ul><p>It returns:</p><ul><li><code>T</code>: Semi-major axis [m].</li><li><code>T</code>: Inclination [rad].</li><li><code>Bool</code>: <code>true</code> if the Newton-Raphson algorithm converged, or <code>false</code> otherwise.</li></ul><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Let&#39;s say we want to compute the Sun-synchronous orbit for a mission that must perform exactly 14 orbits per day:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n_d = 14 * (2π / 86400)</code><code class="nohighlight hljs ansi" style="display:block;">0.0010181087303300256</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a, i, converged = sun_sync_orbit_from_angular_velocity(n_d)</code><code class="nohighlight hljs ansi" style="display:block;">(7.2664592231272645e6, 1.7276602844278286, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a / 1000</code><code class="nohighlight hljs ansi" style="display:block;">7266.4592231272645</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rad2deg(i)</code><code class="nohighlight hljs ansi" style="display:block;">98.98764273008597</code></pre><h2 id="Designing-Sun-Synchronous-Orbits-from-Semi-Major-Axis"><a class="docs-heading-anchor" href="#Designing-Sun-Synchronous-Orbits-from-Semi-Major-Axis">Designing Sun-Synchronous Orbits from Semi-Major Axis</a><a id="Designing-Sun-Synchronous-Orbits-from-Semi-Major-Axis-1"></a><a class="docs-heading-anchor-permalink" href="#Designing-Sun-Synchronous-Orbits-from-Semi-Major-Axis" title="Permalink"></a></h2><p>Given a desired semi-major axis <span>$a_d$</span>, we can compute the inclination that turns the orbit into a Sun-synchronous one by solving numerically:</p><p class="math-container">\[\frac{d\Omega}{dt}(a_d, i_0) = 0.9856473598947981^\circ / s\ .\]</p><p>The function:</p><pre><code class="language-julia hljs">sun_sync_orbit_inclination(a::T1, e::T2 = 0; kwargs...) where {T1 &lt;: Number, T2 &lt;: Number} -&gt; T, Bool</code></pre><p>computes the inclination [rad] of the Sun-synchronous orbit with semi-major axis <code>a</code> [m] and the eccentricity <code>e</code> [ ]. If the latter is omitted, the orbit is considered circular, i.e., <code>e = 0</code>.</p><p>The algorithm here considers only the perturbation terms up to <span>$J_2$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Internally, this function uses the precision obtained by promoting <code>T1</code> and <code>T2</code> to a float-pointing number <code>T</code>.</p></div></div><p>The following keywords are available:</p><ul><li><code>max_iterations::Number</code>: Maximum number of iterations in the Newton-Raphson method.   (<strong>Default</strong> = 30)</li><li><code>tolerance::Union{Nothing, Number}</code>: Residue tolerance to verify if the numerical method   has converged. If it is <code>nothing</code>, <code>√eps(T)</code> will be used, where <code>T</code> is the internal   type for the computations. Notice that the residue unit is [deg / day].   (<strong>Default</strong> = nothing)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong> = <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong> = <code>EGM_2008_J2</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong> = <code>EARTH_EQUATORIAL_RADIUS</code>)</li></ul><p>It returns:</p><ul><li><code>T</code>: Inclination [rad] of the Sun-synchronous orbit with semi-major axis <code>a</code> and   eccentricity <code>e</code>.</li><li><code>Bool</code>: <code>true</code> if the Newton-Raphson algorithm converged, or <code>false</code> otherwise.</li></ul><h3 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h3><p>Let&#39;s find the inclination that turns an orbit with semi-major axis 6819 km and eccentricity 0.0015 into a Sun-synchronous one:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; i, converged = sun_sync_orbit_inclination(6819e3, 0.0015)</code><code class="nohighlight hljs ansi" style="display:block;">(1.6962005973484486, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rad2deg(i)</code><code class="nohighlight hljs ansi" style="display:block;">97.18513543563525</code></pre><h2 id="Designing-Sun-Synchronous-Orbits-from-Inclination"><a class="docs-heading-anchor" href="#Designing-Sun-Synchronous-Orbits-from-Inclination">Designing Sun-Synchronous Orbits from Inclination</a><a id="Designing-Sun-Synchronous-Orbits-from-Inclination-1"></a><a class="docs-heading-anchor-permalink" href="#Designing-Sun-Synchronous-Orbits-from-Inclination" title="Permalink"></a></h2><p>Given a desired inclination <span>$i_d$</span>, we can compute the semi-major axis that turns the orbit into a Sun-synchronous one by solving numerically:</p><p class="math-container">\[\frac{d\Omega}{dt}(a_0, i_d) = 0.9856473598947981^\circ / s\ .\]</p><p>The function:</p><pre><code class="language-julia hljs">sun_sync_orbit_semi_major_axis(i::T1, e::T2 = 0; kwargs...) where {T1 &lt;: Number, T2 &lt;: Number} -&gt; T, Bool
</code></pre><p>compute the semi-major axis [m] of the Sun-synchronous orbit with inclination <code>i</code> [rad] and the eccentricity <code>e</code> [ ]. If the latter is omitted, the orbit is considered circular, i.e., <code>e = 0</code>.</p><p>The algorithm here considers only the perturbation terms up to <span>$J_2$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Internally, this function uses the precision obtained by promoting <code>T1</code> and <code>T2</code> to a float-pointing number <code>T</code>.</p></div></div><p>The following keywords are available:</p><ul><li><code>max_iterations::Number</code>: Maximum number of iterations in the Newton-Raphson method.   (<strong>Default</strong> = 30)</li><li><code>tolerance::Union{Nothing, Number}</code>: Residue tolerance to verify if the numerical method   has converged. If it is <code>nothing</code>, <code>√eps(T)</code> will be used, where <code>T</code> is the internal   type for the computations. Notice that the residue unit is [deg / day].   (<strong>Default</strong> = nothing)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong> = <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong> = <code>EGM_2008_J2</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong> = <code>EARTH_EQUATORIAL_RADIUS</code>)</li></ul><p>It returns:</p><ul><li><code>T</code>: Semi-major axis [m] of the Sun-synchronous orbit with inclination <code>i</code> and   eccentricity <code>e</code>.</li><li><code>Bool</code>: <code>true</code> if the Newton-Raphson algorithm converged, or <code>false</code> otherwise.</li></ul><h3 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h3><p>Let&#39;s find the semi-major axis that turns an orbit with inclination axis 98.190° and eccentricity 0.001987 into a Sun-synchronous one:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a, converged = sun_sync_orbit_semi_major_axis(98.190 |&gt; deg2rad, 0.001987)</code><code class="nohighlight hljs ansi" style="display:block;">(7.077394233340981e6, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a / 1000</code><code class="nohighlight hljs ansi" style="display:block;">7077.394233340981</code></pre><h2 id="Designing-Sun-Synchronous,-Ground-Repeating-Orbits"><a class="docs-heading-anchor" href="#Designing-Sun-Synchronous,-Ground-Repeating-Orbits">Designing Sun-Synchronous, Ground-Repeating Orbits</a><a id="Designing-Sun-Synchronous,-Ground-Repeating-Orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Designing-Sun-Synchronous,-Ground-Repeating-Orbits" title="Permalink"></a></h2><p>The most common type of a Sun-synchronous orbit is a ground-repeating one. In this case, we have a Sun-synchronous orbit, as mentioned before, whose ground track repeats after a finite number of (solar) days. The ground-repeating condition happens if the satellite performs a rational number of orbits per solar day:</p><p class="math-container">\[R_d = I + \frac{N}{D}\ ,\]</p><p>where <span>$R_d$</span> is the number of revolutions per day, and <span>$I, N, D \in \mathbb{N}$</span>. If the greatest common divisor of <span>$N$</span> and <span>$D$</span> is one, the ground track of such an orbit repeats after <span>$NI + D$</span> revolutions, or <span>$D$</span> solar days.</p><p>If an orbit has <span>$R_d$</span> revolutions per solar day, we can compute its angular velocity as follows:</p><p class="math-container">\[\omega_o = R_d \frac{2\pi}{86400}\ .\]</p><p>Hence, we can design a Sun-synchronous, ground-repeating orbit by numerically solving the system:</p><p class="math-container">\[\begin{aligned}
  \frac{d\Omega}{dt}(a_0, i_0) &amp;= 0.9856473598947981^\circ / s\ , \\
  \bar{n}(a_0, i_0) &amp;= R_d \frac{2\pi}{86400}\ ,
\end{aligned}\]</p><p>using the same method we described in the Section <a href="#Designing-Sun-Synchronous-Orbits-from-Angular-Velocity">Designing Sun-Synchronous Orbits from Angular Velocity</a>.</p><p>The function:</p><pre><code class="language-julia hljs">design_sun_sync_ground_repeating_orbit(minimum_repetition::Int, maximum_repetition::Int; kwargs...) -&gt; DataFrame</code></pre><p>lists all the Sun synchronous, ground repeating orbits in which their repetition period is in the interval <code>[minimum_repetition, maximum_repetition]</code> days.</p><p>This function returns a <code>DataFrame</code> with the following columns:</p><ul><li><code>semi_major_axis</code>: Orbit semi-major axis.</li><li><code>altitude</code>: Orbit altitude above the Equator <code>(a - R0)</code>.</li><li><code>inclination</code>: Orbit inclination.</li><li><code>period</code>: Orbital period.</li><li><code>rev_per_days</code>: If the keyword <code>pretify_rev_per_days</code> is <code>false</code>, this column contains   <code>Tuple</code>s with the integer and rational parts of the number of revolutions per day.   Otherwise, it contains a string with a prety representation of the number of revolutions   per day.</li><li><code>adjacent_gt_distance</code>: Distance between two adjacent ground tracks at Equator.</li><li><code>adjacent_gt_angle</code>: Angle between two adjacent ground tracks at Equator measured from the   satellite position.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The units of those columns depends on the keywords.</p></div></div><p>The following keywords are available:</p><ul><li><code>angle_unit::Symbol</code>: Unit for all the angles in the output <code>DataFrame</code>.  It can be <code>:deg</code>   for degrees or <code>:rad</code> for radians.   (<strong>Default</strong>: <code>:deg</code>)</li><li><code>distance_unit::Symbol</code>: The unit for all the distances in the output <code>DataFrame</code>. It can   be <code>:m</code> for meters or <code>:km</code> for kilometers.   (<strong>Default</strong>: <code>:km</code>)</li><li><code>eccentricity::Number</code>: Orbit eccentricity.   (<strong>Default</strong>: 0)</li><li><code>int_rev_per_day::Tuple</code>: <code>Tuple</code> with the integer parts of the number of revolutions per   day to be analyzed.   (<strong>Default</strong> = <code>(13, 14, 15, 16, 17)</code>)</li><li><code>pretity_rev_per_days::Bool</code>: If <code>true</code>, the column with the revolutions per day will be   conveted to a string with a pretty representation of this information.   (<strong>Default</strong>: <code>true</code>)</li><li><code>maximum_altitude::Union{Nothing, Number}</code>: Maximum altitude [m] of the orbits in the   output <code>DataFrame</code>. If it is <code>nothing</code>, the algorithm will not apply a higher limit to   the orbital altitude.   (<strong>Default</strong> = <code>nothing</code>)</li><li><code>minimum_altitude::Union{Nothing, Number}</code>: Minimum altitude [m] of the orbits in the   output <code>DataFrame</code>. If it is <code>nothing</code>, the algorithm will not apply a lower limit to   the orbital altitude.   (<strong>Default</strong> = <code>nothing</code>)</li><li><code>time_unit::Symbol</code>: Unit for all the time values in the output <code>DataFrame</code>.  It can be   <code>:s</code> for seconds, <code>:m</code> for minutes, or <code>:h</code> for hours.   (<strong>Default</strong> = <code>:h</code>)</li><li><code>m0::Number</code>: Standard gravitational parameter for Earth [m³ / s²].   (<strong>Default</strong> = <code>GM_EARTH</code>)</li><li><code>J2::Number</code>: J₂ perturbation term.   (<strong>Default</strong> = <code>EGM_2008_J2</code>)</li><li><code>R0::Number</code>: Earth&#39;s equatorial radius [m].   (<strong>Default</strong> = <code>EARTH_EQUATORIAL_RADIUS</code>)</li><li><code>we::Number</code>: Earth&#39;s angular speed [rad / s].   (<strong>Default</strong>: <code>EARTH_ANGULAR_SPEED</code>)</li></ul><h3 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h3><p>Let&#39;s find all the possible orbits between 650km and 800km that repeat the ground track in, at most, 5 days:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; df = design_sun_sync_ground_repeating_orbit(
           1,
           5;
           minimum_altitude = 650e3,
           maximum_altitude = 800e3
       )</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">5×7 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> semi_major_axis  altitude  inclination  period    rev_per_days  adjacen</span> ⋯
     │<span class="sgr90"> Float64          Float64   Float64      Float64   String        Float64</span> ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │         7044.1    665.964      98.0552   98.1818  14 + ²/₃              ⋯
   2 │         7065.57   687.437      98.142    98.6301  14 + ³/₅
   3 │         7098.09   719.954      98.2747   99.3103  14 + ¹/₂
   4 │         7130.98   752.847      98.4106  100.0     14 + ²/₅
   5 │         7153.13   774.988      98.503   100.465   14 + ¹/₃              ⋯
<span class="sgr36">                                                               2 columns omitted</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(df; crop = :none)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">5×7 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> semi_major_axis  altitude  inclination  period    rev_per_days  adjacent_gt_distance  adjacent_gt_angle </span>
     │<span class="sgr90"> Float64          Float64   Float64      Float64   String        Float64               Float64           </span>
─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │         7044.1    665.964      98.0552   98.1818  14 + ²/₃                   891.252            66.3159
   2 │         7065.57   687.437      98.142    98.6301  14 + ³/₅                   537.002            42.3412
   3 │         7098.09   719.954      98.2747   99.3103  14 + ¹/₂                  1350.87             83.4747
   4 │         7130.98   752.847      98.4106  100.0     14 + ²/₅                   543.811            39.4254
   5 │         7153.13   774.988      98.503   100.465   14 + ¹/₃                   910.164            59.7702</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The designer can use the fields <code>adjacent_gt_distance</code> and <code>adjacent_gt_angle</code> to check whether the mission payload can operate correctly in the orbit. For example, in orbit #4, the payload swath of a remote sensing satellite with a camera must be higher than 543.811 km. Otherwise, there will be gaps in the images.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../ground_track/">« Ground Track</a><a class="docs-footer-nextpage" href="../../../lib/library/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 13 January 2024 19:17">Saturday 13 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
